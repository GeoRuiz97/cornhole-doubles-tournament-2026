<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hardy Diagnostics Cornhole Doubles Tournament 2026</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Barlow+Condensed:wght@400;600;700&family=Barlow:wght@400;500&display=swap" rel="stylesheet">
<!-- Firebase SDKs -->
<script type="module">
import { initializeApp }                        from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, setDoc, onSnapshot, getDoc, deleteDoc }
                                                from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey:            "AIzaSyAyT1KNeWPEbhCSAO5K33iQmwBjHMw_awE",
  authDomain:        "cornholedoublestournament-2026.firebaseapp.com",
  projectId:         "cornholedoublestournament-2026",
  storageBucket:     "cornholedoublestournament-2026.firebasestorage.app",
  messagingSenderId: "998672163064",
  appId:             "1:998672163064:web:1789a449b9f75c1201db0d"
};

const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);
const BRACKET_DOC = doc(db, 'bracket', 'state');

// â”€â”€ Expose Firebase helpers to global scope so non-module code can call them â”€â”€
window._fbSave = async function(data) {
  try { await setDoc(BRACKET_DOC, data); } catch(e) { console.error('Firestore save error:', e); }
};

window._fbListen = function(callback) {
  onSnapshot(BRACKET_DOC, snap => {
    if (snap.exists()) callback(snap.data());
  });
};

window._fbGet = async function() {
  try {
    const snap = await getDoc(BRACKET_DOC);
    return snap.exists() ? snap.data() : null;
  } catch(e) { console.error('Firestore get error:', e); return null; }
};

// â”€â”€ Predictions collection â”€â”€
const PREDS_COL = 'predictions';

window._fbSavePrediction = async function(name, picks, existingDocId) {
  try {
    // Use a stable doc ID based on name so updates overwrite the same document
    const docId = existingDocId || name.trim().toLowerCase().replace(/[^a-z0-9]/g,'_');
    const ref = doc(db, PREDS_COL, docId);
    await setDoc(ref, { name: name.trim(), picks, submittedAt: Date.now(), docId });
    return docId;
  } catch(e) { console.error('Prediction save error:', e); return null; }
};

// Get a single prediction by name key
window._fbGetPrediction = async function(name) {
  try {
    const docId = name.trim().toLowerCase().replace(/[^a-z0-9]/g,'_');
    const snap = await getDoc(doc(db, PREDS_COL, docId));
    return snap.exists() ? { id: snap.id, ...snap.data() } : null;
  } catch(e) { return null; }
};

// Delete a prediction by doc ID
window._fbDeletePrediction = async function(docId) {
  try {
    await deleteDoc(doc(db, PREDS_COL, docId));
    return true;
  } catch(e) { console.error('Prediction delete error:', e); return false; }
};

window._fbListenPredictions = function(callback) {
  const { collection, onSnapshot: onSnap } = window._fbImports;
  onSnap(collection(db, PREDS_COL), snap => {
    const preds = [];
    snap.forEach(d => preds.push({ id: d.id, ...d.data() }));
    callback(preds);
  });
};

// Store imports for use in predictions
import { collection, onSnapshot as onSnap2 } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
window._fbImports = { collection, onSnapshot: onSnap2 };

// Signal that Firebase is ready
window._fbReady = true;
document.dispatchEvent(new Event('fbReady'));
</script>
<style>
  :root {
    --bg:       #0e1117;
    --surface:  #161b25;
    --card:     #1e2535;
    --border:   #2a3347;
    --accent:   #f5a623;
    --red:      #e84545;
    --green:    #2ecc71;
    --text:     #e8edf5;
    --muted:    #7a8499;
    --bye-bg:   #142010;
    --bye-text: #5dba3a;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    min-height: 100vh;
    overflow-x: auto;
  }

  /* â”€â”€ Header â”€â”€ */
  header {
    text-align: center;
    padding: 44px 24px 30px;
    border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, #07090e 0%, var(--bg) 100%);
  }
  .trophy-icon {
    font-size: 2.8rem;
    display: block;
    margin-bottom: 10px;
    filter: drop-shadow(0 0 16px rgba(245,166,35,0.7));
  }

  header h1 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(1.8rem, 4.5vw, 3.5rem);
    letter-spacing: 4px;
    background: linear-gradient(135deg, #f5a623 0%, #f7dc6f 50%, #f5a623 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  header p {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.9rem;
    letter-spacing: 5px;
    text-transform: uppercase;
    color: var(--muted);
    margin-top: 10px;
  }

  /* â”€â”€ Controls â”€â”€ */
  .controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    padding: 12px 28px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
  }
  .legend {
    display: flex;
    gap: 20px;
    align-items: center;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--muted);
  }
  .legend-item { display: flex; align-items: center; gap: 7px; }
  .legend-dot  { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }
  .hint {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 1px;
    color: var(--muted);
    font-style: italic;
  }
  .btn-reset {
    background: transparent;
    border: 1px solid var(--red);
    color: var(--red);
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 6px 18px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.18s;
    white-space: nowrap;
  }
  .btn-reset:hover { background: var(--red); color: #fff; }
  .btn-reshuffle {
    background: transparent;
    border: 1px solid #3d9bd4;
    color: #3d9bd4;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 6px 18px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.18s;
    white-space: nowrap;
  }
  .btn-reshuffle:hover { background: #3d9bd4; color: #fff; }
  .btn-reshuffle:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    pointer-events: none;
  }
  /* â”€â”€ Lock button â”€â”€ */
  .lock-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }
  .btn-lock {
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    transition: transform 0.15s;
  }
  .btn-lock:hover { transform: scale(1.12); }
  .lock-icon {
    font-size: 1.6rem;
    line-height: 1;
    filter: drop-shadow(0 0 4px rgba(245,166,35,0.4));
    transition: all 0.25s;
  }
  .lock-status {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    transition: color 0.25s;
  }
  .lock-area.unlocked .lock-status { color: var(--green); }
  .lock-area.unlocked .lock-icon   { filter: drop-shadow(0 0 6px rgba(46,204,113,0.6)); }

  /* Locked overlay on slots */
  .bracket-locked .team-slot:not(.s-bye):not(.s-empty) {
    cursor: not-allowed;
  }
  /* When unlocked, always show pointer on clickable slots */
  .team-slot:not(.s-bye):not(.s-empty) {
    cursor: pointer;
  }
  .btn-reset:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    pointer-events: none;
  }

  /* Password modal */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 10000;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(4px);
  }
  .modal-overlay.visible { display: flex; }
  .modal-box {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 36px 32px 28px;
    width: 320px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    animation: modalPop 0.2s ease;
  }
  @keyframes modalPop {
    from { transform: scale(0.88); opacity: 0; }
    to   { transform: scale(1);    opacity: 1; }
  }
  .modal-lock-icon { font-size: 2.4rem; margin-bottom: 12px; display: block; }
  .modal-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.4rem;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 6px;
  }
  .modal-sub {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.82rem;
    color: var(--muted);
    letter-spacing: 1px;
    margin-bottom: 20px;
  }
  .modal-input {
    width: 100%;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    font-size: 1rem;
    padding: 10px 14px;
    text-align: center;
    letter-spacing: 3px;
    outline: none;
    transition: border-color 0.18s;
    margin-bottom: 8px;
  }
  .modal-input:focus { border-color: var(--accent); }
  .modal-input.error { border-color: var(--red); animation: shake 0.3s ease; }
  @keyframes shake {
    0%,100% { transform: translateX(0); }
    25%      { transform: translateX(-8px); }
    75%      { transform: translateX(8px); }
  }
  .modal-error {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.78rem;
    color: var(--red);
    letter-spacing: 1px;
    min-height: 18px;
    margin-bottom: 14px;
  }
  .modal-btn {
    width: 100%;
    background: var(--accent);
    border: none;
    border-radius: 6px;
    color: #000;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.1rem;
    letter-spacing: 3px;
    padding: 10px;
    cursor: pointer;
    transition: opacity 0.18s;
  }
  .modal-btn:hover { opacity: 0.85; }
  .modal-cancel {
    display: block;
    margin-top: 12px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.78rem;
    color: var(--muted);
    letter-spacing: 1px;
    cursor: pointer;
    text-decoration: underline;
    background: none;
    border: none;
    width: 100%;
  }
  .modal-cancel:hover { color: var(--text); }


  /* â”€â”€ Bracket wrapper â”€â”€ */
  .bracket-wrapper {
    padding: 36px 32px 100px;
    overflow-x: auto;
  }
  .bracket {
    display: flex;
    align-items: flex-start;
    min-width: max-content;
  }

  /* â”€â”€ Round column â”€â”€ */
  .round-col {
    display: flex;
    flex-direction: column;
    width: 240px;
    flex-shrink: 0;
  }
  .round-header {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.05rem;
    letter-spacing: 3px;
    color: var(--accent);
    text-align: center;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 12px;
  }
  .round-matches {
    display: flex;
    flex-direction: column;
    flex: 1;
  }

  /* â”€â”€ Match block â”€â”€ */
  /* Each match block is positioned so its card is vertically centered
     within the vertical space that corresponds to its paired R1 matches. */
  .match-block {
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 0 10px;
  }

  /* Game label â€” sits above the card, no overlap */
  .game-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.65rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 5px;
    padding-left: 2px;
  }

  /* Match card */
  .match-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 7px;
    overflow: hidden;
    transition: border-color 0.18s, box-shadow 0.18s;
  }
  .match-card:hover {
    border-color: #3a4e6e;
    box-shadow: 0 3px 16px rgba(0,0,0,0.45);
  }

  /* â”€â”€ Team slot â”€â”€ */
  .team-slot {
    padding: 10px 14px;
    min-height: 56px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    position: relative;
    cursor: pointer;
    user-select: none;
    transition: background 0.14s;
  }
  .team-slot + .team-slot {
    border-top: 1px solid var(--border);
  }
  .team-slot:hover:not(.s-bye):not(.s-empty) {
    background: rgba(245,166,35,0.07);
  }
  .team-slot.s-winner { background: rgba(46,204,113,0.1); }
  .team-slot.s-loser  { opacity: 0.35; }
  .team-slot.s-bye    { background: var(--bye-bg); cursor: default; }
  .team-slot.s-empty  { cursor: default; }

  .slot-tag {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--muted);
    line-height: 1;
    margin-bottom: 3px;
  }
  .slot-names {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.92rem;
    font-weight: 600;
    color: var(--text);
    line-height: 1.25;
  }
  .team-slot.s-winner .slot-names { color: var(--green); }
  .team-slot.s-bye    .slot-tag   { color: var(--bye-text); opacity: 0.9; }
  .team-slot.s-bye    .slot-names { color: var(--bye-text); font-weight: 500; font-size: 0.82rem; }
  .team-slot.s-empty  .slot-names { color: var(--muted); font-weight: 400; font-size: 0.82rem; }

  .win-check {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--green);
    font-size: 0.9rem;
    font-weight: 700;
  }

  /* â”€â”€ Connector column â”€â”€ */
  .connector-col {
    width: 40px;
    min-width: 40px;
    flex-shrink: 0;
    align-self: stretch;
    position: relative;
  }

  /* â”€â”€ Champion box â”€â”€ */
  .champion-col {
    width: 420px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .champion-header {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3rem;
    letter-spacing: 4px;
    color: var(--accent);
    margin-bottom: 18px;
    text-align: center;
  }
  .champion-box {
    width: 380px;
    background: linear-gradient(145deg, #15110a, #241c08, #1a1404);
    border: 3px solid var(--accent);
    border-radius: 20px;
    padding: 48px 36px;
    text-align: center;
    box-shadow: 0 0 60px rgba(245,166,35,0.25), 0 0 16px rgba(245,166,35,0.12), inset 0 1px 0 rgba(255,255,255,0.06);
    transition: box-shadow 0.5s, border-color 0.5s;
  }
  .champion-box.crowned {
    box-shadow: 0 0 110px rgba(245,166,35,0.7), 0 0 44px rgba(245,166,35,0.45), 0 0 10px rgba(247,220,111,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
    border-color: #f7dc6f;
    animation: champPulse 2s ease-in-out infinite;
  }
  @keyframes champPulse {
    0%, 100% { box-shadow: 0 0 110px rgba(245,166,35,0.7), 0 0 44px rgba(245,166,35,0.45), inset 0 1px 0 rgba(255,255,255,0.1); }
    50%       { box-shadow: 0 0 150px rgba(245,166,35,0.9), 0 0 70px rgba(245,166,35,0.6), inset 0 1px 0 rgba(255,255,255,0.14); }
  }
  .champ-trophy { font-size: 5rem; display: block; margin-bottom: 20px; filter: drop-shadow(0 0 22px rgba(245,166,35,1)); transition: transform 0.4s; }
  .champ-trophy.pop { animation: trophyBounce 0.65s ease forwards; }
  @keyframes trophyBounce {
    0%   { transform: scale(1); }
    40%  { transform: scale(1.4) rotate(-8deg); }
    70%  { transform: scale(0.9) rotate(4deg); }
    100% { transform: scale(1.15); }
  }
  .champ-label   { font-family: 'Bebas Neue', sans-serif; font-size: 1rem; letter-spacing: 7px; color: var(--accent); }
  .champ-divider { width: 70px; height: 2px; background: linear-gradient(90deg, transparent, var(--accent), transparent); margin: 14px auto; border: none; }
  .champ-team    { font-family: 'Bebas Neue', sans-serif; font-size: 3.2rem; color: #fff; margin-top: 6px; line-height: 1.05; text-shadow: 0 0 24px rgba(245,166,35,0.45); }
  .champ-players { font-size: 1.05rem; color: #c8d0dd; margin-top: 12px; line-height: 1.8; }

  /* scrollbar */
  ::-webkit-scrollbar { height: 5px; width: 5px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  /* â”€â”€ Champion Announcement Overlay â”€â”€ */
  #champOverlay {
    position: fixed;
    inset: 0;
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    background: rgba(7, 9, 14, 0.75);
    padding: 20px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
  }
  #champOverlay.visible {
    opacity: 1;
    pointer-events: all;
  }
  @keyframes overlayFadeIn {
    from { opacity: 0; }
    to   { opacity: 1; }
  }
  .champ-overlay-panel {
    background: linear-gradient(160deg, #161b25 0%, #0e1117 100%);
    border: 1px solid rgba(245,166,35,0.35);
    border-radius: 20px;
    width: min(680px, 100%);
    max-height: 85vh;
    overflow-y: auto;
    box-shadow: 0 0 80px rgba(245,166,35,0.2), 0 30px 80px rgba(0,0,0,0.7);
    animation: panelSlideUp 0.5s cubic-bezier(0.2,0.9,0.3,1) forwards;
    position: relative;
  }
  @keyframes panelSlideUp {
    from { transform: translateY(40px); opacity: 0; }
    to   { transform: translateY(0);    opacity: 1; }
  }
  .champ-overlay-header {
    text-align: center;
    padding: 40px 32px 24px;
    border-bottom: 1px solid rgba(245,166,35,0.15);
    position: relative;
  }
  .champ-overlay-eyebrow {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.78rem;
    letter-spacing: 6px;
    text-transform: uppercase;
    color: var(--accent);
    margin-bottom: 16px;
    opacity: 0;
    animation: fadeUp 0.4s 0.3s ease forwards;
  }
  .champ-overlay-trophy {
    font-size: 4.5rem;
    display: block;
    margin-bottom: 12px;
    filter: drop-shadow(0 0 28px rgba(245,166,35,0.9));
    opacity: 0;
    animation: trophyDrop 0.6s 0.5s cubic-bezier(0.2,1.4,0.4,1) forwards;
  }
  @keyframes trophyDrop {
    from { transform: scale(0.3) translateY(-30px); opacity: 0; }
    to   { transform: scale(1)   translateY(0);     opacity: 1; }
  }
  .champ-overlay-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(2.2rem, 6vw, 3.8rem);
    letter-spacing: 4px;
    background: linear-gradient(135deg, #f5a623 0%, #f7dc6f 50%, #f5a623 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1;
    opacity: 0;
    animation: fadeUp 0.5s 0.8s ease forwards;
  }
  .champ-overlay-players {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 1.1rem;
    color: var(--muted);
    letter-spacing: 2px;
    margin-top: 8px;
    opacity: 0;
    animation: fadeUp 0.5s 1s ease forwards;
  }
  @keyframes fadeUp {
    from { transform: translateY(12px); opacity: 0; }
    to   { transform: translateY(0);    opacity: 1; }
  }
  .champ-overlay-body {
    padding: 24px 32px 32px;
  }
  .champ-overlay-lb-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1rem;
    letter-spacing: 4px;
    color: var(--accent);
    margin-bottom: 14px;
    text-align: center;
    opacity: 0;
    animation: fadeUp 0.5s 1.1s ease forwards;
  }
  .champ-overlay-lb {
    display: flex;
    flex-direction: column;
    gap: 8px;
    opacity: 0;
    animation: fadeUp 0.5s 1.2s ease forwards;
  }
  .col-row {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    transition: border-color 0.2s;
  }
  .col-row.col-top {
    border-color: var(--accent);
    background: rgba(245,166,35,0.07);
  }
  .col-row.col-second { border-color: rgba(192,192,192,0.4); }
  .col-row.col-third  { border-color: rgba(180,100,20,0.4);  }
  .col-rank {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3rem;
    width: 28px;
    text-align: center;
    flex-shrink: 0;
    color: var(--muted);
  }
  .col-row.col-top    .col-rank { color: #f5d020; }
  .col-row.col-second .col-rank { color: #c0c0c0; }
  .col-row.col-third  .col-rank { color: #b46414; }
  .col-name-wrap { flex: 1; min-width: 0; }
  .col-name {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 1rem;
    font-weight: 700;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .col-breakdown {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.7rem;
    color: var(--muted);
    white-space: normal;
  }
  .col-score {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3rem;
    color: var(--green);
    flex-shrink: 0;
  }
  .col-dismiss {
    position: absolute;
    top: 16px; right: 16px;
    background: rgba(255,255,255,0.06);
    border: 1px solid var(--border);
    color: var(--muted);
    font-size: 1rem;
    width: 32px; height: 32px;
    border-radius: 50%;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.15s;
    z-index: 10002;
  }
  .col-dismiss:hover { background: rgba(255,255,255,0.12); color: var(--text); }
  .col-called-it {
    font-size: 0.65rem;
    background: rgba(245,166,35,0.15);
    border: 1px solid rgba(245,166,35,0.4);
    color: var(--accent);
    border-radius: 3px;
    padding: 1px 5px;
    letter-spacing: 0.5px;
    font-family: 'Barlow Condensed', sans-serif;
    flex-shrink: 0;
  }

  /* â”€â”€ Change picks button â”€â”€ */
  .btn-change-picks {
    width: 100%;
    background: transparent;
    border: 1px solid var(--accent);
    color: var(--accent);
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.85rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    transition: all 0.15s;
  }
  .btn-change-picks:hover { background: rgba(245,166,35,0.1); }
  .pick-locked-notice {
    background: rgba(46,204,113,0.08);
    border: 1px solid rgba(46,204,113,0.25);
    border-radius: 6px;
    padding: 10px 12px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.82rem;
    color: var(--green);
    letter-spacing: 0.5px;
    line-height: 1.5;
    margin-bottom: 10px;
  }
  .pick-partial-lock {
    background: rgba(245,166,35,0.07);
    border: 1px solid rgba(245,166,35,0.2);
    border-radius: 6px;
    padding: 10px 12px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    color: var(--accent);
    letter-spacing: 0.5px;
    line-height: 1.5;
    margin-bottom: 10px;
  }

  /* â”€â”€ Fire streak badge â”€â”€ */
  .streak-badge {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    font-size: 0.75rem;
    margin-left: 4px;
    animation: flamePulse 0.8s ease-in-out infinite alternate;
    vertical-align: middle;
  }
  @keyframes flamePulse {
    from { transform: scale(1);    filter: drop-shadow(0 0 2px #f5a623); }
    to   { transform: scale(1.18); filter: drop-shadow(0 0 6px #e84545); }
  }

  /* â”€â”€ Page layout (no sidebar, full width) â”€â”€ */
  .page-body {
    display: block;
  }

  /* â”€â”€ Floating action button â”€â”€ */
  .fab-group {
    position: fixed;
    bottom: 28px;
    right: 28px;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
    z-index: 1000;
  }
  .fab {
    width: 52px;
    height: 52px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.3rem;
    box-shadow: 0 4px 18px rgba(0,0,0,0.5);
    transition: transform 0.18s, box-shadow 0.18s;
  }
  .fab:hover { transform: scale(1.1); box-shadow: 0 6px 24px rgba(0,0,0,0.6); }
  .fab-pick { background: var(--accent); color: #000; }
  .fab-lb   { background: var(--card); color: var(--text); border: 1px solid var(--border); }
  .fab-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.72rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--muted);
    text-align: right;
  }

  /* â”€â”€ Sliding panel (shared) â”€â”€ */
  .slide-panel {
    position: fixed;
    bottom: 0; right: 0;
    width: 380px;
    max-width: 100vw;
    max-height: 90vh;
    background: var(--surface);
    border: 1px solid var(--border);
    border-bottom: none;
    border-radius: 16px 16px 0 0;
    box-shadow: 0 -8px 40px rgba(0,0,0,0.5);
    z-index: 1100;
    display: flex;
    flex-direction: column;
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.4,0,0.2,1);
    overflow: hidden;
  }
  .slide-panel.open { transform: translateY(0); }
  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px 12px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .panel-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.2rem;
    letter-spacing: 3px;
    color: var(--accent);
  }
  .panel-close {
    background: none;
    border: none;
    color: var(--muted);
    font-size: 1.2rem;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    line-height: 1;
    transition: color 0.15s;
  }
  .panel-close:hover { color: var(--text); }
  .panel-body {
    padding: 16px 20px;
    overflow-y: auto;
    flex: 1;
  }

  /* â”€â”€ Prediction form â”€â”€ */
  .pred-mode-tabs {
    display: flex;
    gap: 6px;
    margin-bottom: 14px;
  }
  .pred-tab {
    flex: 1;
    padding: 7px 4px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 1px;
    text-transform: uppercase;
    text-align: center;
    border: 1px solid var(--border);
    border-radius: 5px;
    cursor: pointer;
    color: var(--muted);
    background: transparent;
    transition: all 0.15s;
  }
  .pred-tab.active {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(245,166,35,0.08);
  }
  .pred-input {
    width: 100%;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 5px;
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    font-size: 0.9rem;
    padding: 9px 12px;
    margin-bottom: 12px;
    outline: none;
    transition: border-color 0.15s;
  }
  .pred-input:focus { border-color: var(--accent); }
  .pred-select {
    width: 100%;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 5px;
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    font-size: 0.88rem;
    padding: 9px 12px;
    margin-bottom: 12px;
    outline: none;
    cursor: pointer;
  }
  .pred-btn {
    width: 100%;
    background: var(--accent);
    border: none;
    border-radius: 6px;
    color: #000;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.05rem;
    letter-spacing: 2px;
    padding: 10px;
    cursor: pointer;
    transition: opacity 0.15s;
    margin-top: 4px;
  }
  .pred-btn:hover { opacity: 0.85; }
  .pred-msg {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    text-align: center;
    margin-top: 10px;
    min-height: 18px;
    letter-spacing: 0.5px;
  }
  .pred-msg.success { color: var(--green); }
  .pred-msg.error   { color: var(--red); }

  /* â”€â”€ Clear downstream user picks when a pick changes â”€â”€ */
function clearDownstreamPicks(changedMatchId) {
  // Find all matches in later rounds that source from this match (directly or indirectly)
  const toClear = new Set([changedMatchId]);
  ST.rounds.forEach(round => {
    round.forEach(m => {
      if (toClear.has(m.srcA) || toClear.has(m.srcB)) {
        delete fullPicks[m.id];
        toClear.add(m.id);
      }
    });
  });
}

/* â”€â”€ Round-by-round picker â”€â”€ */
  .rr-progress {
    display: flex;
    gap: 4px;
    margin-bottom: 14px;
    align-items: center;
  }
  .rr-step {
    flex: 1;
    height: 4px;
    border-radius: 2px;
    background: var(--border);
    transition: background 0.2s;
  }
  .rr-step.done    { background: var(--green); }
  .rr-step.current { background: var(--accent); }

  .rr-round-label {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1rem;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 10px;
  }
  .rr-round-sub {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.78rem;
    color: var(--muted);
    letter-spacing: 1px;
    margin-bottom: 12px;
  }
  .rr-matches {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 14px;
  }
  .rr-match {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }
  .rr-match-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    padding: 5px 10px 3px;
    border-bottom: 1px solid var(--border);
  }
  .rr-team-btn {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    background: transparent;
    border: none;
    border-bottom: 1px solid var(--border);
    color: var(--text);
    cursor: pointer;
    transition: background 0.12s;
    text-align: left;
  }
  .rr-team-btn:last-child { border-bottom: none; }
  .rr-team-btn:hover:not(:disabled) { background: rgba(245,166,35,0.07); }
  .rr-team-btn.rr-selected {
    background: rgba(245,166,35,0.13);
    border-left: 3px solid var(--accent);
  }
  .rr-team-btn:disabled { opacity: 0.4; cursor: default; }
  /* Correct/wrong result coloring for locked matches */
  .rr-team-btn.rr-correct {
    background: rgba(46,204,113,0.12) !important;
    border-left: 3px solid var(--green) !important;
    opacity: 1 !important;
  }
  .rr-team-btn.rr-correct .rr-team-name { color: var(--green); }
  .rr-team-btn.rr-correct .rr-team-label { color: rgba(46,204,113,0.7); }
  .rr-team-btn.rr-wrong {
    background: rgba(232,69,69,0.08) !important;
    border-left: 3px solid var(--red) !important;
    opacity: 1 !important;
  }
  .rr-team-btn.rr-wrong .rr-team-name { color: var(--red); opacity: 0.7; }
  .rr-team-btn.rr-wrong .rr-team-label { color: rgba(232,69,69,0.5); }
  .rr-team-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.65rem;
    color: var(--muted);
    letter-spacing: 1px;
    display: block;
    line-height: 1;
  }
  .rr-team-name {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.92rem;
    font-weight: 600;
    color: var(--text);
    display: block;
    line-height: 1.2;
  }
  .rr-team-btn.rr-selected .rr-team-name { color: var(--accent); }
  .rr-check { margin-left: auto; color: var(--accent); font-size: 1rem; }
  .rr-nav {
    display: flex;
    gap: 8px;
    margin-top: 4px;
  }
  .rr-nav-btn {
    flex: 1;
    padding: 8px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.82rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .rr-nav-btn.prev {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--muted);
  }
  .rr-nav-btn.prev:hover { border-color: var(--text); color: var(--text); }
  .rr-nav-btn.next {
    background: var(--accent);
    border: 1px solid var(--accent);
    color: #000;
  }
  .rr-nav-btn.next:hover { opacity: 0.85; }

  /* â”€â”€ Leaderboard â”€â”€ */
  .leaderboard-list {
    display: flex;
    flex-direction: column;
    gap: 7px;
  }
  .lb-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 9px 12px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
  }
  .lb-row.lb-top { border-color: var(--accent); background: rgba(245,166,35,0.07); }
  .lb-rank {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.05rem;
    color: var(--muted);
    width: 22px;
    text-align: center;
    flex-shrink: 0;
  }
  .lb-row.lb-top .lb-rank { color: var(--accent); }
  .lb-name-wrap {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-width: 0;
  }
  .lb-name {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.92rem;
    font-weight: 600;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .lb-breakdown {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.68rem;
    color: var(--muted);
    letter-spacing: 0.3px;
    white-space: normal;
    line-height: 1.4;
    word-break: break-word;
  }
  .lb-score {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.05rem;
    color: var(--green);
    flex-shrink: 0;
  }
  .lb-type {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: var(--muted);
    flex-shrink: 0;
  }
  .lb-empty {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.85rem;
    color: var(--muted);
    text-align: center;
    padding: 20px 0;
    font-style: italic;
  }
  .lb-delete {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--muted);
    font-size: 0.85rem;
    padding: 2px 4px;
    border-radius: 3px;
    flex-shrink: 0;
    line-height: 1;
    transition: color 0.15s, background 0.15s;
    display: none; /* hidden by default, shown when unlocked */
  }
  .lb-delete:hover { color: var(--red); background: rgba(232,69,69,0.1); }
  body.admin-unlocked .lb-delete { display: inline-flex; align-items: center; }
</style>
</head>
<body>

<header>
  <span class="trophy-icon">ğŸ†</span>
  <h1>Hardy Diagnostics Cornhole Doubles Tournament 2026</h1>
  <p>Single Elimination &nbsp;Â·&nbsp; 27 Teams &nbsp;Â·&nbsp; Random Draw</p>
</header>

<!-- Password Modal -->
<div class="modal-overlay" id="pwModal">
  <div class="modal-box">
    <svg class="modal-lock-icon" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color:var(--accent);margin-bottom:12px;">
      <rect x="3" y="11" width="18" height="11" rx="2" ry="2" fill="rgba(245,166,35,0.12)" stroke="var(--accent)"/>
      <path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="var(--accent)"/>
      <circle cx="12" cy="16" r="1.2" fill="var(--accent)" stroke="none"/>
    </svg>
    <div class="modal-title">Enter Password</div>
    <div class="modal-sub">Admin access required</div>
    <input class="modal-input" id="pwInput" type="password" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
      onkeydown="if(event.key==='Enter') submitPassword()" autocomplete="off" />
    <div class="modal-error" id="pwError"></div>
    <button class="modal-btn" onclick="submitPassword()">Unlock</button>
    <button class="modal-cancel" onclick="closeModal()">Cancel</button>
  </div>
</div>

<div class="controls">
  <div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:var(--green)"></div>Winner</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--bye-text)"></div>Bye (auto-advance)</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--muted)"></div>TBD</div>
  </div>
  <span class="hint" id="lockHint">ğŸ”’ Bracket is locked â€” view only</span>
  <div style="display:flex;align-items:center;gap:14px;">
    <button class="btn-reshuffle" id="reshuffleBtn" onclick="reshuffleBracket()" disabled>â‡„ Re-Shuffle</button>
    <button class="btn-reset" id="resetBtn" onclick="resetBracket()" disabled>â†º Reset Bracket</button>
    <div class="lock-area" id="lockArea">
      <button class="btn-lock" onclick="toggleLock()" title="Lock / Unlock bracket editing">
        <span id="lockIcon">
          <!-- Locked SVG -->
          <svg id="svgLocked" viewBox="0 0 24 24" width="28" height="28" fill="none" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2" fill="rgba(100,120,160,0.18)" stroke="#7a8499"/>
            <path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="#7a8499"/>
            <circle cx="12" cy="16" r="1.3" fill="#7a8499" stroke="none"/>
          </svg>
          <!-- Unlocked SVG -->
          <svg id="svgUnlocked" viewBox="0 0 24 24" width="28" height="28" fill="none" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2" fill="rgba(46,204,113,0.15)" stroke="#2ecc71"/>
            <path d="M7 11V7a5 5 0 0 1 9.9-1" stroke="#2ecc71"/>
            <circle cx="12" cy="16" r="1.3" fill="#2ecc71" stroke="none"/>
          </svg>
        </span>
        <span class="lock-status" id="lockStatus">Locked</span>
      </button>
    </div>
  </div>
</div>

<div class="page-body">
  <div class="bracket-wrapper">
    <div class="bracket" id="bracket"></div>
  </div>
</div>

<!-- â”€â”€ Floating Action Buttons â”€â”€ -->
<div class="fab-group">
  <div style="display:flex;flex-direction:column;align-items:center;gap:4px;">
    <span class="fab-label">Leaderboard</span>
    <button class="fab fab-lb" onclick="togglePanel('lbPanel')" title="Leaderboard">ğŸ…</button>
  </div>
  <div style="display:flex;flex-direction:column;align-items:center;gap:4px;">
    <span class="fab-label">Make a Pick</span>
    <button class="fab fab-pick" onclick="togglePanel('pickPanel')" title="Make your pick">ğŸ¯</button>
  </div>
</div>

<!-- â”€â”€ Pick Panel â”€â”€ -->
<div class="slide-panel" id="pickPanel">
  <div class="panel-header">
    <span class="panel-title">ğŸ¯ Pick Your Bracket</span>
    <button class="panel-close" onclick="closePanel('pickPanel')">âœ•</button>
  </div>
  <div class="panel-body">
    <!-- Name + lookup -->
    <div style="display:flex;gap:8px;margin-bottom:10px;">
      <input class="pred-input" id="predName" type="text" placeholder="Enter your name" maxlength="40" style="margin-bottom:0;flex:1;" />
      <button class="pred-btn" style="width:auto;padding:9px 14px;margin-top:0;flex-shrink:0;font-size:0.82rem;" onclick="lookupExistingPick()">Look Up</button>
    </div>
    <!-- Scoring key -->
    <div id="scoringKey" style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:12px;">
      <span style="font-family:'Barlow Condensed',sans-serif;font-size:0.7rem;letter-spacing:1px;color:var(--muted);width:100%;text-transform:uppercase;">Points per correct pick:</span>
    </div>
    <!-- Round-by-round picker (always shown) -->
    <div class="rr-progress" id="rrProgress"></div>
    <div class="rr-round-label" id="rrRoundLabel"></div>
    <div class="rr-round-sub"  id="rrRoundSub"></div>
    <div class="rr-matches"    id="rrMatches"></div>
    <div class="rr-nav">
      <button class="rr-nav-btn prev" id="rrPrevBtn" onclick="rrNav(-1)">â† Back</button>
      <button class="rr-nav-btn next" id="rrNextBtn" onclick="rrNav(1)">Next â†’</button>
    </div>
    <button class="pred-btn" id="predSubmitBtn" onclick="submitPrediction()" style="margin-top:14px;">Submit Bracket</button>
    <div class="pred-msg" id="predMsg"></div>
  </div>
</div>

<!-- â”€â”€ Leaderboard Panel â”€â”€ -->
<div class="slide-panel" id="lbPanel">
  <div class="panel-header">
    <span class="panel-title">ğŸ… Bracket Prediction Leaderboard</span>
    <button class="panel-close" onclick="closePanel('lbPanel')">âœ•</button>
  </div>
  <div class="panel-body">
    <div class="leaderboard-list" id="leaderboard">
      <div class="lb-empty">No picks submitted yet</div>
    </div>
  </div>
</div>

<!-- â”€â”€ Champion Announcement Overlay â”€â”€ -->
<div id="champOverlay">
  <div class="champ-overlay-panel">
    <button class="col-dismiss" onclick="dismissChampOverlay()" title="Dismiss">âœ•</button>
    <div class="champ-overlay-header">
      <span class="champ-overlay-eyebrow">ğŸ‰ Tournament Champion ğŸ‰</span>
      <span class="champ-overlay-trophy">ğŸ†</span>
      <div class="champ-overlay-name"  id="coName">TBD</div>
      <div class="champ-overlay-players" id="coPlayers"></div>
    </div>
    <div class="champ-overlay-body">
      <div class="champ-overlay-lb-title">Final Standings</div>
      <div class="champ-overlay-lb" id="coLeaderboard"></div>
    </div>
  </div>
</div>

<script>
/* â”€â”€â”€ TEAMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const TEAMS = [
  { id:'T1',  label:'Team 1',  p1:'Alani Vasquez',     p2:'Geo Ruiz' },
  { id:'T2',  label:'Team 2',  p1:'Wes Koyama',        p2:'Ernesto Diaz' },
  { id:'T3',  label:'Team 3',  p1:'Byanca Villalba',   p2:'Arturo Villalba' },
  { id:'T4',  label:'Team 4',  p1:'Isaiah Valdez',     p2:'Maria Pimentel' },
  { id:'T5',  label:'Team 5',  p1:'Jezi Morales',      p2:'Jerry Moxley' },
  { id:'T6',  label:'Team 6',  p1:'Michael Bulan',     p2:'Anthony Nunez' },
  { id:'T7',  label:'Team 7',  p1:'Mike Morris',       p2:'Gavin Kelly' },
  { id:'T8',  label:'Team 8',  p1:'Edgar Rodriguez',   p2:'Salvador Diaz' },
  { id:'T9',  label:'Team 9',  p1:'Miles Amby',        p2:'Megan Roesner' },
  { id:'T11', label:'Team 11', p1:'Raymond Carlyle',   p2:'Carlos Cruz' },
  { id:'T12', label:'Team 12', p1:'Sarah Susenbach',   p2:'Gabriella Fuentes' },
  { id:'T13', label:'Team 13', p1:'Brian Tom',         p2:'Kyle Zook' },
  { id:'T14', label:'Team 14', p1:'Frank Ramirez',     p2:'Jaime Pasos' },
  { id:'T15', label:'Team 15', p1:'Victoria Regalado', p2:'Vanessa Ramos-Solorio' },
  { id:'T16', label:'Team 16', p1:'Kelly Blair',       p2:'Arianna Leon' },
  { id:'T17', label:'Team 17', p1:'Anthony Nunez',     p2:'Michael Bulan' },
  { id:'T18', label:'Team 18', p1:'Angel Garcia',      p2:'Manuel Saldivar' },
  { id:'T19', label:'Team 19', p1:'Adam Acosta',       p2:'Daniel Gonzales' },
  { id:'T20', label:'Team 20', p1:'Gabriel Diaz',      p2:'Fabian Juarez' },
  { id:'T21', label:'Team 21', p1:'Nadine Cepeda',     p2:'Joey Gonzalez' },
  { id:'T22', label:'Team 22', p1:'Charles Arandia',   p2:'Emannuel Leon-R' },
  { id:'T23', label:'Team 23', p1:'Jacob Rosseti',     p2:'Mario Corral' },
  { id:'T24', label:'Team 24', p1:'Melissa Evans',     p2:'Alynna Duncan' },
  { id:'T25', label:'Team 25', p1:'Rob Nievez',        p2:'Vanessa Hernandez' },
  { id:'T26', label:'Team 26', p1:'Bobby Ortiz',       p2:'Josiah Guzman' },
  { id:'T27', label:'Team 27', p1:'Daniel Vazquez',    p2:'Susana Estrada' },
];

/* â”€â”€â”€ RNG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function makeRng(seed) {
  let s = seed >>> 0;
  return () => { s = (Math.imul(1664525, s) + 1013904223) >>> 0; return s / 0x100000000; };
}
function shuffle(arr, rng) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* â”€â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let ST        = null;
let _ignoreNext = false; // prevent echo when we save our own write

function getSeed(savedSeed) {
  // Use seed from Firestore if available, otherwise generate new one
  if (savedSeed) return parseInt(savedSeed);
  return Math.random() * 1e9 | 0;
}

function buildBracket(seedValue) {
  const computedSeed = getSeed(seedValue);
  const rng = makeRng(computedSeed);
  window._currentSeed = computedSeed; // store so we can save to Firestore
  const shuffled = shuffle(TEAMS, rng);

  // 27 teams â†’ 32 slots â†’ 5 byes.
  // Spread byes evenly: every ~5-6 positions gets a bye.
  // We'll place them at positions 5,11,17,23,29 in the 32-slot array (0-indexed).
  // Then shuffle the non-bye positions randomly.
  // This ensures no two byes are adjacent.
  const BYE_POSITIONS = new Set([4, 10, 16, 22, 28]);
  const slots = new Array(32).fill(null);
  let teamIdx = 0;
  for (let i = 0; i < 32; i++) {
    if (!BYE_POSITIONS.has(i)) slots[i] = shuffled[teamIdx++];
    // BYE positions stay null
  }

  // Build R1: 16 matches
  const r1 = [];
  for (let i = 0; i < 16; i++) {
    const top = slots[i * 2];
    const bot = slots[i * 2 + 1];
    const isByeMatch = top === null || bot === null;
    const autoWinner = top === null ? bot : (bot === null ? top : null);
    r1.push({
      id: `R1G${i+1}`,
      top: top === null ? 'BYE' : top,
      bottom: bot === null ? 'BYE' : bot,
      winner: autoWinner,
      isBye: isByeMatch,
    });
  }

  // Build subsequent rounds
  const rounds = [r1];
  while (rounds[rounds.length-1].length > 1) {
    const prev = rounds[rounds.length-1];
    const rIdx = rounds.length + 1;
    const next = prev.reduce((acc, m, i) => {
      if (i % 2 === 0) {
        acc.push({
          id: `R${rIdx}G${acc.length+1}`,
          top: null, bottom: null, winner: null,
          srcA: prev[i].id, srcB: prev[i+1].id,
        });
      }
      return acc;
    }, []);
    rounds.push(next);
  }

  ST = { rounds };

  // Auto-propagate bye winners
  r1.forEach(m => { if (m.winner) propagate(m.id, m.winner); });

  // Picks are restored separately via Firestore in applyFirestoreState()
}

function findMatch(id) {
  for (const round of ST.rounds)
    for (const m of round)
      if (m.id === id) return m;
  return null;
}

function applyFirestoreState(data) {
  // Rebuild bracket with the saved seed so team order matches
  buildBracket(data.seed);

  // Replay saved picks
  const picks = data.picks || [];
  picks.forEach(({ mid, wid }) => {
    const m = findMatch(mid);
    if (!m) return;
    const team = [m.top, m.bottom].find(t => t && t !== 'BYE' && t.id === wid);
    if (team) { m.winner = team; propagate(mid, team); }
  });

  render();
}

function propagate(srcId, team) {
  for (const round of ST.rounds) {
    for (const m of round) {
      let changed = false;
      if (m.srcA === srcId) { m.top    = team; changed = true; }
      if (m.srcB === srcId) { m.bottom = team; changed = true; }
      // If a winner was already set for this match but no longer matches either slot, clear it
      if (changed && m.winner && m.winner !== 'BYE') {
        const topId = (m.top && m.top !== 'BYE') ? m.top.id : null;
        const botId = (m.bottom && m.bottom !== 'BYE') ? m.bottom.id : null;
        if (m.winner.id !== topId && m.winner.id !== botId) {
          m.winner = null;
          clearDownstream(m.id);
        }
      }
    }
  }
}

function clearDownstream(srcId) {
  for (const round of ST.rounds) {
    for (const m of round) {
      if (m.srcA === srcId) m.top    = null;
      if (m.srcB === srcId) m.bottom = null;
      if ((m.srcA === srcId || m.srcB === srcId) && m.winner) {
        m.winner = null;
        clearDownstream(m.id);
      }
    }
  }
}

function savePicks() {
  if (!window._fbSave) return;
  const picks = ST.rounds.flat()
    .filter(m => m.winner && m.winner !== 'BYE')
    .map(m => ({ mid: m.id, wid: m.winner.id }));
  const data = { seed: String(window._currentSeed), picks };
  _ignoreNext = true;
  window._fbSave(data);
}

/* â”€â”€â”€ LOCK / PASSWORD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const PASSWORD     = 'WellnessPeeps';
const SESSION_MS   = 30 * 60 * 1000; // 30 minutes
let   isUnlocked   = false;
let   lockTimer    = null;

function checkSession() {
  const exp = localStorage.getItem('hd2026_unlock_exp');
  if (exp && Date.now() < parseInt(exp)) {
    applyUnlock();
  }
}

function applyUnlock() {
  isUnlocked = true;
  document.getElementById('svgLocked').style.display   = 'none';
  document.getElementById('svgUnlocked').style.display = '';
  document.getElementById('lockStatus').textContent = 'Unlocked';
  document.getElementById('lockArea').classList.add('unlocked');
  document.getElementById('lockHint').textContent   = 'ğŸ”“ Bracket editing enabled';
  document.getElementById('resetBtn').disabled      = false;
  document.getElementById('reshuffleBtn').disabled  = false;
  document.body.classList.add('admin-unlocked');
  document.getElementById('bracket').classList.remove('bracket-locked');

  // Auto-lock after 30 min
  if (lockTimer) clearTimeout(lockTimer);
  lockTimer = setTimeout(lock, SESSION_MS);
}

function lock() {
  isUnlocked = false;
  localStorage.removeItem('hd2026_unlock_exp');
  if (lockTimer) clearTimeout(lockTimer);
  document.getElementById('svgLocked').style.display   = '';
  document.getElementById('svgUnlocked').style.display = 'none';
  document.getElementById('lockStatus').textContent = 'Locked';
  document.getElementById('lockArea').classList.remove('unlocked');
  document.getElementById('lockHint').textContent   = 'ğŸ”’ Bracket is locked â€” view only';
  document.getElementById('resetBtn').disabled      = true;
  document.getElementById('reshuffleBtn').disabled  = true;
  document.body.classList.remove('admin-unlocked');
  document.getElementById('bracket').classList.add('bracket-locked');
}

function toggleLock() {
  if (isUnlocked) {
    lock();
  } else {
    openModal();
  }
}

function openModal() {
  document.getElementById('pwInput').value = '';
  document.getElementById('pwError').textContent = '';
  document.getElementById('pwInput').classList.remove('error');
  document.getElementById('pwModal').classList.add('visible');
  setTimeout(() => document.getElementById('pwInput').focus(), 80);
}

function closeModal() {
  document.getElementById('pwModal').classList.remove('visible');
}

function submitPassword() {
  const val = document.getElementById('pwInput').value;
  if (val === PASSWORD) {
    const exp = Date.now() + SESSION_MS;
    localStorage.setItem('hd2026_unlock_exp', exp);
    closeModal();
    applyUnlock();
  } else {
    const inp = document.getElementById('pwInput');
    inp.classList.remove('error');
    void inp.offsetWidth; // restart animation
    inp.classList.add('error');
    document.getElementById('pwError').textContent = 'Incorrect password. Try again.';
    inp.value = '';
  }
}

// Close modal if clicking outside the box
document.getElementById('pwModal').addEventListener('click', function(e) {
  if (e.target === this) closeModal();
});

/* â”€â”€â”€ CANVAS POLYFILL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    this.beginPath();
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r);
    this.lineTo(x + w, y + h - r);
    this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    this.lineTo(x + r, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r);
    this.lineTo(x, y + r);
    this.quadraticCurveTo(x, y, x + r, y);
    this.closePath();
  };
}

/* â”€â”€â”€ CONFETTI (regular rounds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const CONFETTI_COLORS = ['#f5a623','#f7dc6f','#2ecc71','#3498db','#e74c3c','#9b59b6','#1abc9c','#ffffff'];

function launchConfetti(originEl) {
  const rect    = originEl.getBoundingClientRect();
  const originX = rect.left + rect.width  / 2;
  const originY = rect.top  + rect.height / 2;

  const canvas = document.createElement('canvas');
  canvas.style.cssText = 'position:fixed;inset:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;';
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  const pieces = Array.from({ length: 55 }, () => {
    const angle = (Math.random() * Math.PI * 1.2) - Math.PI * 0.6;
    const speed = 3 + Math.random() * 6;
    const size  = 5 + Math.random() * 7;
    return {
      x: originX, y: originY,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 5,
      rot: Math.random() * 360, rotV: (Math.random() - 0.5) * 14,
      w: size, h: size * (0.35 + Math.random() * 0.5),
      color: CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)],
      alpha: 1, circle: Math.random() > 0.6,
    };
  });

  let frame = 0;
  const totalFrames = 80;
  function tick() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let anyAlive = false;
    pieces.forEach(p => {
      p.vy += 0.28; p.x += p.vx; p.y += p.vy; p.rot += p.rotV;
      p.alpha = Math.max(0, 1 - frame / totalFrames);
      if (p.alpha > 0.01) anyAlive = true;
      ctx.save(); ctx.globalAlpha = p.alpha;
      ctx.translate(p.x, p.y); ctx.rotate(p.rot * Math.PI / 180);
      ctx.fillStyle = p.color;
      if (p.circle) { ctx.beginPath(); ctx.arc(0,0,p.w/2,0,Math.PI*2); ctx.fill(); }
      else ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    });
    frame++;
    if (anyAlive) requestAnimationFrame(tick); else canvas.remove();
  }
  requestAnimationFrame(tick);
}

/* â”€â”€â”€ FIREWORKS + CORNHOLE BAGS (Championship) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function launchChampionCelebration() {
  // Glow the champion box
  const box = document.getElementById('champBox');
  if (box) box.classList.add('crowned');
  const trophy = document.getElementById('champTrophy');
  if (trophy) { trophy.classList.remove('pop'); void trophy.offsetWidth; trophy.classList.add('pop'); }

  // Show announcement overlay after a short delay so fireworks start first
  const champ = ST.rounds[ST.rounds.length-1][0]?.winner;
  if (champ && champ !== 'BYE') {
    setTimeout(() => showChampOverlay(champ), 1800);
  }

  const canvas = document.createElement('canvas');
  canvas.style.cssText = 'position:fixed;inset:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;';
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  const W = canvas.width, H = canvas.height;
  const FW_COLORS = ['#f5a623','#f7dc6f','#e74c3c','#3498db','#2ecc71','#9b59b6','#ff6b9d','#ffffff','#00d2ff'];
  const BAG_COLORS = ['#e74c3c','#3498db','#f5a623','#2ecc71','#9b59b6'];

  let particles = [];
  let rockets   = [];
  let bags      = [];
  let frame     = 0;
  const TOTAL   = 900; // ~15 seconds at 60fps

  function makeRocket() {
    const x = W * (0.15 + Math.random() * 0.7);
    return {
      x, y: H + 10,
      tx: x + (Math.random() - 0.5) * 120,
      ty: H * (0.1 + Math.random() * 0.45),
      speed: 8 + Math.random() * 6,
      color: FW_COLORS[Math.floor(Math.random() * FW_COLORS.length)],
      trail: [],
      exploded: false,
    };
  }

  function explode(rx, ry, color) {
    const count = 80 + Math.floor(Math.random() * 60);
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.3;
      const speed = 2 + Math.random() * 7;
      particles.push({
        x: rx, y: ry,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        color: Math.random() > 0.3 ? color : '#ffffff',
        alpha: 1,
        size: 2 + Math.random() * 3,
        decay: 0.012 + Math.random() * 0.012,
        sparkle: Math.random() > 0.6,
      });
    }
    // Starburst ring
    for (let i = 0; i < 12; i++) {
      const angle = (Math.PI * 2 * i) / 12;
      particles.push({
        x: rx, y: ry,
        vx: Math.cos(angle) * 9,
        vy: Math.sin(angle) * 9,
        color: '#ffffff',
        alpha: 1, size: 3, decay: 0.025, sparkle: false,
      });
    }
  }

  function makeBag() {
    // Bags launched from bottom corners and center, arcing up
    const startX = Math.random() > 0.5 ? W * 0.1 : W * 0.9;
    const color  = BAG_COLORS[Math.floor(Math.random() * BAG_COLORS.length)];
    const angle  = startX < W / 2
      ? -(0.8 + Math.random() * 0.5)   // launched right
      : -(Math.PI - 0.8 - Math.random() * 0.5); // launched left
    const speed  = 14 + Math.random() * 8;
    return {
      x: startX, y: H + 20,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      rot: Math.random() * 360,
      rotV: (Math.random() - 0.5) * 18,
      color, alpha: 1, size: 18 + Math.random() * 10,
      alive: true,
    };
  }

  // Schedule rockets
  const rocketSchedule = [];
  for (let i = 0; i < 30; i++) {
    rocketSchedule.push(Math.floor(Math.random() * (TOTAL - 80)));
  }
  rocketSchedule.sort((a,b) => a - b);

  // Schedule bags
  const bagSchedule = [];
  for (let i = 0; i < 22; i++) {
    bagSchedule.push(Math.floor(Math.random() * (TOTAL - 40)));
  }

  function drawBag(ctx, b) {
    ctx.save();
    ctx.globalAlpha = b.alpha;
    ctx.translate(b.x, b.y);
    ctx.rotate(b.rot * Math.PI / 180);
    // Draw cornhole bag: rounded square with stitching
    const s = b.size;
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.roundRect(-s/2, -s/2, s, s, s * 0.2);
    ctx.fill();
    // Stitching lines
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1.2;
    ctx.strokeRect(-s/2 + s*0.15, -s/2 + s*0.15, s*0.7, s*0.7);
    // Center dot
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(0, 0, s * 0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function tick() {
    ctx.clearRect(0, 0, W, H);

    // Launch rockets on schedule
    if (rocketSchedule.length && frame >= rocketSchedule[0]) {
      rockets.push(makeRocket());
      rocketSchedule.shift();
    }
    // Launch bags on schedule
    if (bagSchedule.length && frame >= bagSchedule[0]) {
      bags.push(makeBag());
      bagSchedule.shift();
    }

    // Update & draw rockets
    rockets = rockets.filter(r => {
      if (r.exploded) return false;
      const dx = r.tx - r.x, dy = r.ty - r.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < r.speed) {
        explode(r.x, r.y, r.color);
        // Flash
        ctx.fillStyle = 'rgba(255,255,255,0.18)';
        ctx.fillRect(0,0,W,H);
        r.exploded = true;
        return false;
      }
      r.trail.push({ x: r.x, y: r.y });
      if (r.trail.length > 12) r.trail.shift();
      r.x += (dx / dist) * r.speed;
      r.y += (dy / dist) * r.speed;
      // Draw trail
      r.trail.forEach((pt, i) => {
        ctx.save();
        ctx.globalAlpha = (i / r.trail.length) * 0.6;
        ctx.fillStyle = r.color;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
      // Draw rocket head
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(r.x, r.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      return true;
    });

    // Update & draw particles
    particles = particles.filter(p => {
      p.vx *= 0.97; p.vy *= 0.97; p.vy += 0.08;
      p.x += p.vx; p.y += p.vy;
      p.alpha = Math.max(0, p.alpha - p.decay);
      if (p.alpha < 0.01) return false;
      ctx.save();
      ctx.globalAlpha = p.sparkle ? p.alpha * (0.5 + 0.5 * Math.sin(frame * 0.4)) : p.alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      return true;
    });

    // Update & draw bags
    bags = bags.filter(b => {
      b.vx *= 0.995;
      b.vy += 0.45; // gravity
      b.x  += b.vx;
      b.y  += b.vy;
      b.rot += b.rotV;
      // Fade when off screen
      if (b.y > H + 60) { b.alive = false; return false; }
      b.alpha = Math.min(1, Math.max(0, 1 - (frame / TOTAL) * 0.5));
      drawBag(ctx, b);
      return b.alive;
    });

    frame++;
    if (frame < TOTAL) requestAnimationFrame(tick);
    else canvas.remove();
  }

  requestAnimationFrame(tick);
}

/* â”€â”€â”€ INTERACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function clickSlot(matchId, slot) {
  if (!isUnlocked) return; // bracket is locked
  const m = findMatch(matchId);
  if (!m) return;
  const team = slot === 'top' ? m.top : m.bottom;
  if (!team || team === 'BYE') return;

  if (m.winner?.id === team.id) {
    m.winner = null;
    clearDownstream(matchId);
    savePicks();
    render();
  } else {
    m.winner = team;
    propagate(matchId, team);
    savePicks();
    render();

    // Fire confetti from the winning slot after DOM updates
    requestAnimationFrame(() => {
      const card = document.querySelector(`[data-id="${matchId}"]`);
      const slotEls = card ? card.querySelectorAll('.team-slot') : [];
      const origin  = slotEls[slot === 'top' ? 0 : 1] || card || document.getElementById('bracket');
      const isChamp = ST.rounds[ST.rounds.length - 1][0]?.id === matchId;
      if (isChamp) launchChampionCelebration();
      else launchConfetti(origin);
    });
  }
}

function resetBracket() {
  if (!isUnlocked) return;
  if (!confirm('Reset bracket progression? Team matchups will stay the same, but all results will be cleared.')) return;
  // Rebuild with the SAME seed â€” keeps team order, clears all picks
  buildBracket(window._currentSeed);
  render();
  if (window._fbSave) {
    _ignoreNext = true;
    window._fbSave({ seed: String(window._currentSeed), picks: [] });
  }
}

function reshuffleBracket() {
  if (!isUnlocked) return;
  if (!confirm('Re-shuffle teams? This will randomize all matchups and clear all results.')) return;
  // Build with NO seed â€” generates a brand new random seed
  buildBracket();
  render();
  if (window._fbSave) {
    _ignoreNext = true;
    window._fbSave({ seed: String(window._currentSeed), picks: [] });
  }
}

/* â”€â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const ROUND_NAMES = ['Round 1', 'Round 2', 'Quarterfinals', 'Semifinals', 'Championship'];

// Fixed heights (px) â€” consistent across all rounds
const SLOT_H    = 56;   // height of one team slot
const MATCH_H   = SLOT_H * 2 + 1; // match card total height
const LABEL_H   = 24;  // game label height
const GAP_R1    = 20;  // gap between match blocks in R1
// Full height one R1 match block occupies in the column:
const BLOCK_H   = LABEL_H + MATCH_H + GAP_R1;

function render() {
  const el = document.getElementById('bracket');
  el.innerHTML = '';

  ST.rounds.forEach((round, ri) => {
    // Each match in round ri spans 2^ri R1 blocks vertically
    const span      = Math.pow(2, ri);
    const blockSpan = span * BLOCK_H; // total height for this match

    const col = document.createElement('div');
    col.className = 'round-col';

    // Header
    const hdr = document.createElement('div');
    hdr.className = 'round-header';
    hdr.textContent = ROUND_NAMES[ri] || `Round ${ri+1}`;
    col.appendChild(hdr);

    // Matches
    const matchesEl = document.createElement('div');
    matchesEl.className = 'round-matches';

    round.forEach((match, mi) => {
      const block = document.createElement('div');
      block.className = 'match-block';
      block.style.height = `${blockSpan}px`;

      // Game label
      const lbl = document.createElement('div');
      lbl.className = 'game-label';
      lbl.textContent = `Game ${mi + 1}`;
      block.appendChild(lbl);

      // Card
      const card = document.createElement('div');
      card.className = 'match-card';
      card.setAttribute('data-id', match.id);
      card.appendChild(buildSlot(match, 'top'));
      card.appendChild(buildSlot(match, 'bottom'));
      block.appendChild(card);

      matchesEl.appendChild(block);
    });

    col.appendChild(matchesEl);
    el.appendChild(col);

    // After last round: add connector + champion box inline
    if (ri < ST.rounds.length - 1) {
      const conn = document.createElement('div');
      conn.className = 'connector-col';
      conn.setAttribute('data-ri', ri);
      el.appendChild(conn);
    } else {
      // This is the final round â€” add a short connector then champion box
      const finalConn = document.createElement('div');
      finalConn.className = 'connector-col';
      finalConn.setAttribute('data-ri', ri);
      finalConn.setAttribute('data-final', '1');
      el.appendChild(finalConn);

      const finalWinner = ST.rounds[ST.rounds.length - 1][0]?.winner;
      const champCol = document.createElement('div');
      champCol.className = 'champion-col';

      // Vertically center the champion box relative to the final match
      const finalSpan = Math.pow(2, ri) * BLOCK_H;
      champCol.style.height = `${finalSpan}px`;
      champCol.style.paddingTop = '40px'; // offset for round header

      champCol.innerHTML = `
        <div class="champion-header">ğŸ† Champion</div>
        <div class="champion-box" id="champBox">
          <span class="champ-trophy" id="champTrophy">ğŸ†</span>
          <div class="champ-label">Tournament Champion</div>
          <hr class="champ-divider">
          <div class="champ-team">${finalWinner ? finalWinner.label : 'TBD'}</div>
          <div class="champ-players">${finalWinner ? `${finalWinner.p1}<br>${finalWinner.p2}` : '<span style="color:var(--muted);font-size:0.82rem;">Awaiting finalist</span>'}</div>
        </div>`;
      el.appendChild(champCol);
    }
  });

  setTimeout(drawConnectors, 40);
}

/* â”€â”€â”€ STREAK CALCULATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function getTeamWinCount(teamId) {
  let count = 0;
  for (const round of ST.rounds) {
    for (const m of round) {
      if (m.winner && m.winner !== 'BYE' && m.winner.id === teamId) {
        // Only count non-bye wins
        const opponentSlot = m.top?.id === teamId ? m.bottom : m.top;
        if (opponentSlot && opponentSlot !== 'BYE') count++;
      }
    }
  }
  return count;
}

function buildSlot(match, slot) {
  const raw      = slot === 'top' ? match.top : match.bottom;
  // Normalize: treat undefined/null as empty, 'BYE' string as bye, anything else as a team object
  const isBye    = raw === 'BYE';
  const isEmpty  = raw === null || raw === undefined;
  const team     = (!isBye && !isEmpty) ? raw : null;
  const isWinner = team && match.winner && match.winner !== 'BYE' && match.winner.id === team.id;
  const isLoser  = team && match.winner && match.winner !== 'BYE' && match.winner.id !== team.id;

  const div = document.createElement('div');
  div.className = 'team-slot' +
    (isBye    ? ' s-bye'    : '') +
    (isEmpty  ? ' s-empty'  : '') +
    (isWinner ? ' s-winner' : '') +
    (isLoser  ? ' s-loser'  : '');
  div.style.minHeight = `${SLOT_H}px`;

  if (isBye) {
    div.innerHTML = `<div class="slot-tag">Bye</div><div class="slot-names">Auto-Advance âœ“</div>`;
  } else if (isEmpty) {
    div.innerHTML = `<div class="slot-names">TBD</div>`;
  } else {
    const wins = getTeamWinCount(team.id);
    const fireHTML = wins >= 2 ? `<span class="streak-badge" title="${wins} wins in a row!">ğŸ”¥${wins >= 3 ? wins : ''}</span>` : '';
    div.innerHTML = `
      <div class="slot-tag">${team.label}</div>
      <div class="slot-names">${team.p1} &amp; ${team.p2} ${fireHTML}</div>
      ${isWinner ? '<span class="win-check">âœ“</span>' : ''}`;
    div.addEventListener('click', () => clickSlot(match.id, slot));
    div.title = `Click to advance ${team.label}`;
  }

  return div;
}

/* â”€â”€â”€ SVG CONNECTORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function drawConnectors() {
  document.querySelectorAll('.connector-svg').forEach(e => e.remove());

  const bracketEl  = document.getElementById('bracket');
  const roundCols  = [...bracketEl.querySelectorAll('.round-col')];
  const connCols   = [...bracketEl.querySelectorAll('.connector-col')];

  connCols.forEach((col, ri) => {
    const fromCol = roundCols[ri];
    const toCol   = roundCols[ri + 1];
    if (!fromCol || !toCol) return;

    const fromCards = [...fromCol.querySelectorAll('.match-card')];
    const toCards   = [...toCol.querySelectorAll('.match-card')];

    const colRect = col.getBoundingClientRect();
    if (colRect.height < 1) return;

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.classList.add('connector-svg');
    svg.style.cssText = `position:absolute;top:0;left:0;width:${colRect.width}px;height:${colRect.height}px;overflow:visible;pointer-events:none;`;
    col.appendChild(svg);

    const COLOR = '#2e3d55';
    const W     = '1.5';

    function ln(x1, y1, x2, y2) {
      const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      l.setAttribute('x1', x1); l.setAttribute('y1', y1);
      l.setAttribute('x2', x2); l.setAttribute('y2', y2);
      l.setAttribute('stroke', COLOR); l.setAttribute('stroke-width', W);
      l.setAttribute('stroke-linecap', 'round');
      svg.appendChild(l);
    }

    toCards.forEach((toCard, i) => {
      const c1 = fromCards[i * 2];
      const c2 = fromCards[i * 2 + 1];
      if (!c1 || !c2 || !toCard) return;

      const top   = colRect.top;
      const y1    = c1.getBoundingClientRect().top    + c1.getBoundingClientRect().height / 2 - top;
      const y2    = c2.getBoundingClientRect().top    + c2.getBoundingClientRect().height / 2 - top;
      const yn    = toCard.getBoundingClientRect().top + toCard.getBoundingClientRect().height / 2 - top;
      const ymid  = (y1 + y2) / 2;
      const xL    = 0;
      const xMid  = colRect.width / 2;
      const xR    = colRect.width;

      ln(xL,   y1,   xMid, y1);    // left card top â†’ midpoint
      ln(xL,   y2,   xMid, y2);    // left card bottom â†’ midpoint
      ln(xMid, y1,   xMid, y2);    // vertical bridge
      ln(xMid, ymid, xR,   ymid);  // center â†’ right
    });
  });
}

window.addEventListener('resize', () => { drawConnectors(); });

/* â”€â”€â”€ PANEL CONTROLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function togglePanel(id) {
  const panel = document.getElementById(id);
  const isOpen = panel.classList.contains('open');
  // Close all panels first
  document.querySelectorAll('.slide-panel').forEach(p => p.classList.remove('open'));
  if (!isOpen) panel.classList.add('open');
}
function closePanel(id) {
  document.getElementById(id).classList.remove('open');
}
// NOTE: No click-outside listener â€” panels only close via the X button

/* â”€â”€â”€ PREDICTIONS & LEADERBOARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let fullPicks  = {};   // matchId â†’ teamId
let rrRound    = 0;    // current round index in round-by-round picker
let allPreds   = [];
let myDocId    = null; // Firestore doc ID for current user's prediction
let isEditMode = false;

const RNAMES      = ['Round 1','Round 2','Quarterfinals','Semifinals','Championship'];
const ROUND_PTS   = [1, 2, 4, 8, 16]; // points per correct pick per round

function populateScoringKey() {
  const el = document.getElementById('scoringKey');
  if (!el) return;
  // Clear badge children (keep the label span)
  [...el.querySelectorAll('.score-badge')].forEach(b => b.remove());
  RNAMES.forEach((name, i) => {
    const badge = document.createElement('span');
    badge.className = 'score-badge';
    badge.style.cssText = `
      background:rgba(245,166,35,${0.06 + i * 0.04});
      border:1px solid rgba(245,166,35,${0.2 + i * 0.1});
      border-radius:4px;
      padding:3px 7px;
      font-family:'Barlow Condensed',sans-serif;
      font-size:0.72rem;
      color:var(--accent);
      letter-spacing:0.5px;
      white-space:nowrap;
    `;
    badge.textContent = `${name}: ${ROUND_PTS[i]}pt`;
    el.appendChild(badge);
  });
}

function populateChampSelect() { /* no-op â€” champion-only mode removed */ }

/* â”€â”€ Clear downstream user picks when a pick changes â”€â”€ */
function clearDownstreamPicks(changedMatchId) {
  // Find all matches in later rounds that source from this match (directly or indirectly)
  const toClear = new Set([changedMatchId]);
  ST.rounds.forEach(round => {
    round.forEach(m => {
      if (toClear.has(m.srcA) || toClear.has(m.srcB)) {
        delete fullPicks[m.id];
        toClear.add(m.id);
      }
    });
  });
}

/* â”€â”€ Round-by-round picker â”€â”€ */

// Resolve which team the user has picked to come out of a source match.
// Falls back to the actual bracket team for R1 (which has real teams).
function resolvePickedTeam(srcMatchId) {
  const srcMatch = findMatch(srcMatchId);
  if (!srcMatch) return null;

  const pickedId = fullPicks[srcMatchId];
  if (pickedId) {
    // Find the team object in R1 â€” walk back through srcA/srcB recursively
    return findTeamById(pickedId);
  }
  // If no pick yet for that source match, return null (TBD)
  return null;
}

function findTeamById(teamId) {
  for (const round of ST.rounds) {
    for (const m of round) {
      if (m.top && m.top !== 'BYE' && m.top.id === teamId) return m.top;
      if (m.bottom && m.bottom !== 'BYE' && m.bottom.id === teamId) return m.bottom;
    }
  }
  return null;
}

// Get the two contestants for a match in the user's prediction bracket.
// For R1 use actual teams; for later rounds resolve from user's picks.
function getPredContestants(match, ri) {
  if (ri === 0) {
    // Round 1: use actual seeded teams
    return [match.top, match.bottom];
  }
  // Later rounds: resolve from user's picks of source matches
  const topTeam = match.srcA ? resolvePickedTeam(match.srcA) : match.top;
  const botTeam = match.srcB ? resolvePickedTeam(match.srcB) : match.bottom;
  return [topTeam, botTeam];
}

function renderRRRound() {
  if (!ST) return;
  const rounds = ST.rounds;
  const totalRounds = rounds.length;

  // Progress bar
  const prog = document.getElementById('rrProgress');
  if (prog) {
    prog.innerHTML = '';
    rounds.forEach((_, i) => {
      const s = document.createElement('div');
      s.className = 'rr-step' + (i < rrRound ? ' done' : i === rrRound ? ' current' : '');
      prog.appendChild(s);
    });
  }

  const round  = rounds[rrRound];
  const lbl    = document.getElementById('rrRoundLabel');
  const sub    = document.getElementById('rrRoundSub');
  const matchC = document.getElementById('rrMatches');
  if (!lbl || !sub || !matchC) return;

  const pts = ROUND_PTS[rrRound] || 1;
  lbl.innerHTML = `${RNAMES[rrRound] || `Round ${rrRound+1}`} <span style="font-size:0.7rem;letter-spacing:1px;color:var(--muted);font-family:'Barlow Condensed',sans-serif;">Â· ${pts}pt per correct pick</span>`;

  // Auto-advance BYE matches silently (R1 only â€” later rounds resolved from picks)
  if (rrRound === 0) {
    round.forEach(m => {
      const topBye = m.top === 'BYE' || m.top === null || m.top === undefined;
      const botBye = m.bottom === 'BYE' || m.bottom === null || m.bottom === undefined;
      if (topBye && !botBye && m.bottom?.id) fullPicks[m.id] = m.bottom.id;
      if (botBye && !topBye && m.top?.id)    fullPicks[m.id] = m.top.id;
    });
  }

  // Auto-fill locked matches with the real winner so they don't block progress
  round.forEach(m => {
    if (isMatchLocked(m.id) && !fullPicks[m.id]) {
      fullPicks[m.id] = m.winner.id;
    }
  });

  // Count pickable matches for this round using resolved contestants
  let pickableCount = 0;
  let pickedCount   = 0;
  round.forEach(m => {
    const [topTeam, botTeam] = getPredContestants(m, rrRound);
    const topReal = topTeam && topTeam !== 'BYE' && topTeam.id;
    const botReal = botTeam && botTeam !== 'BYE' && botTeam.id;
    if (topReal && botReal) {
      pickableCount++;
      if (fullPicks[m.id]) pickedCount++;
    } else if ((topReal && !botReal) || (!topReal && botReal)) {
      // One side is BYE/TBD â€” auto-advance the real team
      const realTeam = topReal ? topTeam : botTeam;
      if (realTeam?.id) fullPicks[m.id] = realTeam.id;
    }
  });

  const allPicked = pickedCount === pickableCount && pickableCount > 0;
  sub.innerHTML = `${pickedCount} of ${pickableCount} picked` +
    (allPicked ? ' <span style="color:var(--green);">âœ“ Round complete!</span>' : '');

  matchC.innerHTML = '';
  round.forEach((match, mi) => {
    const [topTeam, botTeam] = getPredContestants(match, rrRound);
    const topBye = !topTeam || topTeam === 'BYE';
    const botBye = !botTeam || botTeam === 'BYE';

    // Skip if both are unknown
    if (topBye && botBye) return;

    const card = document.createElement('div');
    card.className = 'rr-match';

    const mlabel = document.createElement('div');
    mlabel.className = 'rr-match-label';
    mlabel.textContent = `Game ${mi + 1}`;
    card.appendChild(mlabel);

    [[topTeam, topBye], [botTeam, botBye]].forEach(([team, isBye]) => {
      const btn = document.createElement('button');
      btn.className = 'rr-team-btn';

      if (isBye || !team) {
        btn.disabled = true;
        btn.innerHTML = `<span class="rr-team-name" style="color:var(--muted);font-style:italic;">TBD</span>`;
      } else {
        const isSelected = fullPicks[match.id] === team.id;
        if (isSelected) btn.classList.add('rr-selected');
        const locked = isMatchLocked(match.id);
        if (locked) btn.disabled = true;

        // Determine correct/wrong state for locked matches where user has submitted
        let resultClass = '';
        let resultBadge = '';
        if (locked && myDocId) {
          const realWinnerId = findMatch(match.id)?.winner?.id;
          if (isSelected) {
            if (realWinnerId === team.id) {
              resultClass = 'rr-correct';
              resultBadge = '<span style="margin-left:auto;font-size:0.85rem;">âœ“</span>';
            } else {
              resultClass = 'rr-wrong';
              resultBadge = '<span style="margin-left:auto;font-size:0.85rem;">âœ—</span>';
            }
          }
        } else if (locked && !resultBadge) {
          resultBadge = '<span style="font-size:0.65rem;color:var(--muted);margin-left:auto;">ğŸ”’</span>';
        }

        if (resultClass) btn.classList.add(resultClass);
        btn.innerHTML = `
          <div>
            <span class="rr-team-label">${team.label}</span>
            <span class="rr-team-name">${team.p1} &amp; ${team.p2}</span>
          </div>
          ${resultBadge || (isSelected ? '<span class="rr-check">âœ“</span>' : '')}`;
        if (!locked) {
          btn.addEventListener('click', () => {
            fullPicks[match.id] = team.id;
            // If user changes a pick, clear any downstream picks that depended on it
            clearDownstreamPicks(match.id);
            fullPicks[match.id] = team.id; // re-set after clearing
            renderRRRound();
          });
        }
      }
      card.appendChild(btn);
    });

    matchC.appendChild(card);
  });

  // Nav buttons
  const prevBtn = document.getElementById('rrPrevBtn');
  const nextBtn = document.getElementById('rrNextBtn');
  if (prevBtn) prevBtn.style.display = rrRound === 0 ? 'none' : '';

  if (nextBtn) {
    // Check if all real picks in this round are made â€” use resolved contestants
    // so later rounds (where m.top/m.bottom are null) work correctly
    const pickableNow = round.filter(m => {
      const [t, b] = getPredContestants(m, rrRound);
      return t && t !== 'BYE' && t.id && b && b !== 'BYE' && b.id;
    });
    const pickedNow = pickableNow.filter(m => fullPicks[m.id]);
    const roundDone = pickedNow.length === pickableNow.length && pickableNow.length > 0;

    if (rrRound === totalRounds - 1) {
      nextBtn.textContent = 'âœ“ Done';
      nextBtn.disabled    = false;
      nextBtn.style.opacity = '1';
      nextBtn.onclick = () => {
        document.getElementById('predSubmitBtn').scrollIntoView({ behavior: 'smooth' });
      };
    } else {
      nextBtn.textContent   = 'Next Round â†’';
      nextBtn.disabled      = !roundDone;
      nextBtn.style.opacity = roundDone ? '1' : '0.4';
      nextBtn.onclick       = roundDone ? () => rrNav(1) : null;
    }
  }
}

function rrNav(dir) {
  if (!ST) return;
  rrRound = Math.max(0, Math.min(ST.rounds.length - 1, rrRound + dir));
  renderRRRound();
}

async function lookupExistingPick() {
  const name  = document.getElementById('predName').value.trim();
  const msgEl = document.getElementById('predMsg');
  if (!name) { msgEl.className = 'pred-msg error'; msgEl.textContent = 'Enter your name first.'; return; }
  msgEl.className = 'pred-msg'; msgEl.textContent = 'Looking up...';

  // Try stable doc ID first
  let existing = await window._fbGetPrediction?.(name);

  // Fallback: search allPreds in memory (catches old docs with timestamp suffix)
  if (!existing && allPreds.length > 0) {
    existing = allPreds.find(p => p.name?.trim().toLowerCase() === name.toLowerCase()) || null;
    if (existing) {
      // Migrate: re-save under stable doc ID so future lookups work
      myDocId    = existing.docId || existing.id;
      isEditMode = true;
      const picks = existing.picks;
      if (picks?.matchPicks) {
        fullPicks = { ...picks.matchPicks };
        renderRRRound();
      }
      const locked = countLockedPicks(picks);
      msgEl.className = 'pred-msg success';
      msgEl.innerHTML = locked > 0
        ? `<span style="color:var(--accent)">âœ Editing your pick â€” ${locked} match${locked>1?'es':''} already locked.</span>`
        : 'âœ Found your pick! Make changes and click Update.';
      document.getElementById('predSubmitBtn').textContent = 'Update Pick';
      return;
    }
  }

  if (existing) {
    await loadExistingPick(name);
  } else {
    isEditMode = false; myDocId = null;
    msgEl.className = 'pred-msg'; msgEl.textContent = 'No existing pick found â€” enter a new one below.';
    document.getElementById('predSubmitBtn').textContent = 'Submit Pick';
  }
}

// Check if a match is "locked" (result already confirmed in bracket)
function isMatchLocked(matchId) {
  if (!ST) return false;
  const m = findMatch(matchId);
  return !!(m && m.winner && m.winner !== 'BYE');
}

// Returns how many of a user's picks are now locked (can't be changed)
function countLockedPicks(existingPicks) {
  if (!existingPicks || existingPicks.type !== 'full') return 0;
  return Object.entries(existingPicks.matchPicks || {}).filter(([mid]) => isMatchLocked(mid)).length;
}

// Load an existing prediction into the form for editing
async function loadExistingPick(name) {
  if (!window._fbGetPrediction) return;
  const existing = await window._fbGetPrediction(name);
  if (!existing) return;

  myDocId    = existing.docId || existing.id;
  isEditMode = true;
  const picks = existing.picks;

  // Restore full bracket picks
  if (picks.matchPicks) {
    fullPicks = { ...picks.matchPicks };
    rrRound = 0;
    renderRRRound();
  }

  // Show edit notice
  const locked = countLockedPicks(picks);
  const msgEl  = document.getElementById('predMsg');
  if (locked > 0) {
    msgEl.className = 'pred-msg';
    msgEl.innerHTML = `<span style="color:var(--accent)">âœ Editing your pick â€” ${locked} match${locked>1?'es':''} are locked and can no longer be changed.</span>`;
  } else {
    msgEl.className = 'pred-msg success';
    msgEl.textContent = 'âœ Editing your existing pick.';
  }
  document.getElementById('predSubmitBtn').textContent = 'Update Pick';
}

async function submitPrediction() {
  const name  = document.getElementById('predName').value.trim();
  const msgEl = document.getElementById('predMsg');
  msgEl.className = 'pred-msg';
  msgEl.textContent = '';

  if (!name) { msgEl.className = 'pred-msg error'; msgEl.textContent = 'Please enter your name.'; return; }

  // Auto-fill any locked matches with the real bracket winner
  // so late joiners are never blocked by already-played games
  ST.rounds.forEach((round, ri) => {
    round.forEach(m => {
      if (isMatchLocked(m.id) && !fullPicks[m.id]) {
        fullPicks[m.id] = m.winner.id;
      }
    });
  });

  // Require picks for all remaining unlocked non-bye matches
  // Use getPredContestants so later rounds resolve from user picks, not real bracket
  const missingPicks = [];
  ST.rounds.forEach((round, ri) => {
    round.forEach(m => {
      if (isMatchLocked(m.id)) return; // already auto-filled above
      const [t, b] = getPredContestants(m, ri);
      const topReal = t && t !== 'BYE' && t.id;
      const botReal = b && b !== 'BYE' && b.id;
      if (topReal && botReal && !fullPicks[m.id]) {
        missingPicks.push({ m, ri });
      }
    });
  });

  if (missingPicks.length > 0) {
    const firstRi = missingPicks[0].ri;
    msgEl.className = 'pred-msg error';
    msgEl.textContent = 'Please complete all rounds first. You have ' + missingPicks.length + ' pick' + (missingPicks.length > 1 ? 's' : '') + ' missing (starting in ' + (RNAMES[firstRi] || 'Round ' + (firstRi+1)) + ').';
    rrRound = Math.max(0, firstRi);
    renderRRRound();
    return;
  }

  // Block duplicate submissions â€” must Look Up first to edit
  if (!isEditMode) {
    msgEl.textContent = 'Checking for existing pick...';
    const existing = await window._fbGetPrediction?.(name)
      || allPreds.find(p => p.name?.trim().toLowerCase() === name.toLowerCase())
      || null;
    if (existing) {
      msgEl.className = 'pred-msg error';
      msgEl.innerHTML = `You already have a pick under <strong>${name}</strong>. Click <strong>Look Up</strong> to load and edit it.`;
      return;
    }
  }

  // Merge: preserve locked picks from existing submission
  let finalMatchPicks = { ...fullPicks };
  if (isEditMode && myDocId) {
    const existing = await window._fbGetPrediction?.(name);
    if (existing?.picks?.matchPicks) {
      Object.entries(existing.picks.matchPicks).forEach(([mid, wid]) => {
        if (isMatchLocked(mid)) finalMatchPicks[mid] = wid;
      });
    }
  }

  const picks = { type: 'full', matchPicks: finalMatchPicks };
  const wasEditing = isEditMode;
  msgEl.textContent = 'Saving...';
  const savedId = await window._fbSavePrediction(name, picks, myDocId);
  if (savedId) {
    myDocId    = savedId;
    isEditMode = true;
    // Keep fullPicks and rrRound intact so user can see their selections
    // Just re-render so correct/wrong badges update if any matches are locked
    renderRRRound();
    document.getElementById('predSubmitBtn').textContent = 'Update Bracket';
    // Show a persistent helpful message below the button
    msgEl.className = 'pred-msg success';
    msgEl.innerHTML = wasEditing
      ? 'âœ… Bracket updated! Your picks are saved.<br><span style="color:var(--muted);font-size:0.75rem;">To make more changes, just edit above and click Update Bracket again.</span>'
      : 'âœ… Bracket recorded! You\'re all set.<br><span style="color:var(--muted);font-size:0.75rem;">Need to make changes? Type your name and click <strong>Look Up</strong>, then edit your picks.</span>';
  } else {
    msgEl.className = 'pred-msg error';
    msgEl.textContent = 'Error saving. Try again.';
  }
}

function scorePrediction(pred) {
  if (!ST) return { total: 0, byRound: [], maxPossible: 0 };
  const picks = pred.picks;
  if (!picks || !picks.matchPicks) return { total: 0, byRound: [], maxPossible: 0 };

  let total = 0;
  const byRound = [];
  let maxPossible = 0;

  ST.rounds.forEach((round, ri) => {
    const pts     = ROUND_PTS[ri] || Math.pow(2, ri);
    let roundEarned = 0;
    let roundMax    = 0;

    round.forEach(match => {
      // Skip BYE matches
      if (!match.top || match.top === 'BYE' || !match.bottom || match.bottom === 'BYE') return;
      roundMax += pts;
      if (match.winner && match.winner !== 'BYE') {
        if (picks.matchPicks[match.id] === match.winner.id) roundEarned += pts;
      }
    });

    total       += roundEarned;
    maxPossible += roundMax;
    byRound.push({ round: RNAMES[ri] || `Round ${ri+1}`, earned: roundEarned, max: roundMax, pts });
  });

  return { total, byRound, maxPossible };
}

function updateLeaderboard(preds) {
  allPreds = preds;
  const lb = document.getElementById('leaderboard');
  if (!lb) return;
  if (!preds || preds.length === 0) {
    lb.innerHTML = '<div class="lb-empty">No picks yet â€” be the first!</div>';
    return;
  }
  const scored = preds.map(p => {
    const s = scorePrediction(p);
    return {
      name:        p.name,
      score:       s.total,
      maxPossible: s.maxPossible,
      byRound:     s.byRound,
      submittedAt: p.submittedAt || 0,
      docId:       p.docId || p.id,
    };
  }).sort((a,b) => b.score - a.score || a.submittedAt - b.submittedAt);

  lb.innerHTML = '';
  const medals = ['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰'];
  scored.forEach((entry, i) => {
    const row = document.createElement('div');
    row.className = 'lb-row' + (i === 0 && entry.score > 0 ? ' lb-top' : '');

    // Breakdown: show points earned per round
    const RSHORT = ['R1', 'R2', 'QF', 'SF', 'Final'];
    const parts = entry.byRound
      .filter(r => r.earned > 0)
      .map((r, ri) => `${RSHORT[ri] || r.round}: ${r.earned}pt`)
      .join(' Â· ');
    const breakdown = parts
      ? `<span class="lb-breakdown">${parts}</span>`
      : `<span class="lb-breakdown" style="color:var(--muted);font-style:italic;">No correct picks yet</span>`;

    row.innerHTML = `
      <span class="lb-rank">${i < 3 ? medals[i] : i+1}</span>
      <div class="lb-name-wrap">
        <span class="lb-name">${entry.name}</span>
        ${breakdown}
      </div>
      <span class="lb-score">${entry.score}pt${entry.score !== 1 ? 's' : ''}</span>`;

    // Delete button (only visible when admin is unlocked)
    const delBtn = document.createElement('button');
    delBtn.className = 'lb-delete';
    delBtn.title = `Delete ${entry.name}'s pick`;
    delBtn.innerHTML = 'ğŸ—‘';
    delBtn.addEventListener('click', () => deletePrediction(entry.docId, entry.name));
    row.appendChild(delBtn);

    lb.appendChild(row);
  });
}

async function deletePrediction(docId, name) {
  if (!isUnlocked) return;
  if (!confirm(`Delete ${name}'s pick? This cannot be undone.`)) return;
  if (!docId) {
    // Try to find by name if docId is missing (old-format entries)
    const found = allPreds.find(p => p.name?.trim().toLowerCase() === name.toLowerCase());
    docId = found?.docId || found?.id;
  }
  if (!docId) { alert('Could not find this entry to delete.'); return; }
  const ok = await window._fbDeletePrediction?.(docId);
  if (!ok) alert('Error deleting entry. Try again.');
}

/* â”€â”€â”€ CHAMPION ANNOUNCEMENT OVERLAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let _champOverlayShown = false; // only auto-show once per session

function showChampOverlay(champion) {
  if (!champion || champion === 'BYE') return;

  // Populate champion info
  document.getElementById('coName').textContent    = champion.label;
  document.getElementById('coPlayers').textContent = `${champion.p1}  &  ${champion.p2}`;

  // Populate leaderboard
  const lbEl = document.getElementById('coLeaderboard');
  lbEl.innerHTML = '';
  const RSHORT = ['R1','R2','QF','SF','Final'];
  const medals = ['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰'];
  const champId = champion.id;

  const finalStandings = allPreds.map(p => {
    const s = scorePrediction(p);
    return { name: p.name, score: s.total, byRound: s.byRound, submittedAt: p.submittedAt || 0,
             calledIt: p.picks?.matchPicks
               ? Object.values(p.picks.matchPicks).includes(champId) &&
                 ST.rounds[ST.rounds.length-1][0]?.winner?.id === champId &&
                 p.picks.matchPicks[ST.rounds[ST.rounds.length-1][0].id] === champId
               : false };
  }).sort((a,b) => b.score - a.score || a.submittedAt - b.submittedAt);

  if (finalStandings.length === 0) {
    lbEl.innerHTML = '<div style="text-align:center;color:var(--muted);font-family:Barlow Condensed,sans-serif;padding:20px;font-style:italic;">No predictions were submitted.</div>';
  } else {
    finalStandings.forEach((entry, i) => {
      const row = document.createElement('div');
      row.className = 'col-row' + (i===0?' col-top':i===1?' col-second':i===2?' col-third':'');
      const breakdown = entry.byRound.filter(r=>r.earned>0)
        .map((r,ri)=>`${RSHORT[ri]||r.round}: ${r.earned}pt`).join(' Â· ');
      row.innerHTML = `
        <span class="col-rank">${i < 3 ? medals[i] : i+1}</span>
        <div class="col-name-wrap">
          <div class="col-name">${entry.name}</div>
          ${breakdown ? `<div class="col-breakdown">${breakdown}</div>` : ''}
        </div>
        ${entry.calledIt ? '<span class="col-called-it">ğŸ¯ Called It!</span>' : ''}
        <span class="col-score">${entry.score}pt${entry.score!==1?'s':''}</span>`;
      lbEl.appendChild(row);
    });
  }

  document.getElementById('champOverlay').classList.add('visible');
}

function dismissChampOverlay() {
  document.getElementById('champOverlay').classList.remove('visible');
}

// Also dismiss when clicking the dark backdrop (outside the panel)
document.getElementById('champOverlay').addEventListener('click', function(e) {
  if (e.target === this) dismissChampOverlay();
});

/* â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
// Show a loading state while Firebase connects
document.getElementById('bracket').innerHTML =
  '<div style="padding:60px;text-align:center;color:var(--muted);font-family:Barlow Condensed,sans-serif;font-size:1.1rem;letter-spacing:2px;">CONNECTING TO LIVE BRACKET...</div>';

function initApp(firestoreData) {
  if (firestoreData) {
    applyFirestoreState(firestoreData);
  } else {
    // No data in Firestore yet â€” build fresh and save
    buildBracket();
    render();
    if (window._fbSave) {
      window._fbSave({ seed: String(window._currentSeed), picks: [] });
    }
  }

  checkSession();
  document.getElementById('bracket').classList.add('bracket-locked');
  populateScoringKey();

  // â”€â”€ Real-time bracket listener â”€â”€
  if (window._fbListen) {
    window._fbListen(data => {
      if (_ignoreNext) { _ignoreNext = false; return; }
      applyFirestoreState(data);
      if (!isUnlocked) document.getElementById('bracket').classList.add('bracket-locked');
      // Re-score leaderboard with updated bracket state
      updateLeaderboard(allPreds);
      renderRRRound();

      // Show champion overlay for all viewers when champ is set (once per session)
      if (!_champOverlayShown) {
        const champ = ST.rounds[ST.rounds.length-1][0]?.winner;
        if (champ && champ !== 'BYE') {
          _champOverlayShown = true;
          // Small delay so the bracket renders first
          setTimeout(() => showChampOverlay(champ), 800);
        }
      }
    });
  }

  // â”€â”€ Real-time predictions listener â”€â”€
  if (window._fbListenPredictions) {
    window._fbListenPredictions(preds => {
      updateLeaderboard(preds);
      // Re-check overlay in case preds loaded after bracket
      if (!_champOverlayShown) {
        const champ = ST?.rounds[ST.rounds.length-1][0]?.winner;
        if (champ && champ !== 'BYE') {
          _champOverlayShown = true;
          setTimeout(() => showChampOverlay(champ), 600);
        }
      }
    });
  }
}

// Wait for Firebase to be ready, then load state
if (window._fbReady) {
  window._fbGet().then(initApp);
} else {
  document.addEventListener('fbReady', () => {
    window._fbGet().then(initApp);
  });
}
</script>
</body>
</html>
