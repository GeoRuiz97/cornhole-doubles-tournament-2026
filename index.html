<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hardy Diagnostics Cornhole Doubles Tournament 2026</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Barlow+Condensed:wght@400;600;700&family=Barlow:wght@400;500&display=swap" rel="stylesheet">
<!-- Firebase SDKs -->
<script type="module">
import { initializeApp }                        from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, setDoc, onSnapshot, getDoc }
                                                from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey:            "AIzaSyAyT1KNeWPEbhCSAO5K33iQmwBjHMw_awE",
  authDomain:        "cornholedoublestournament-2026.firebaseapp.com",
  projectId:         "cornholedoublestournament-2026",
  storageBucket:     "cornholedoublestournament-2026.firebasestorage.app",
  messagingSenderId: "998672163064",
  appId:             "1:998672163064:web:1789a449b9f75c1201db0d"
};

const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);
const BRACKET_DOC = doc(db, 'bracket', 'state');

// ‚îÄ‚îÄ Expose Firebase helpers to global scope so non-module code can call them ‚îÄ‚îÄ
window._fbSave = async function(data) {
  try { await setDoc(BRACKET_DOC, data); } catch(e) { console.error('Firestore save error:', e); }
};

window._fbListen = function(callback) {
  onSnapshot(BRACKET_DOC, snap => {
    if (snap.exists()) callback(snap.data());
  });
};

window._fbGet = async function() {
  try {
    const snap = await getDoc(BRACKET_DOC);
    return snap.exists() ? snap.data() : null;
  } catch(e) { console.error('Firestore get error:', e); return null; }
};

// ‚îÄ‚îÄ Predictions collection ‚îÄ‚îÄ
const PREDS_COL = 'predictions';

window._fbSavePrediction = async function(name, picks, existingDocId) {
  try {
    // Use a stable doc ID based on name so updates overwrite the same document
    const docId = existingDocId || name.trim().toLowerCase().replace(/[^a-z0-9]/g,'_');
    const ref = doc(db, PREDS_COL, docId);
    await setDoc(ref, { name: name.trim(), picks, submittedAt: Date.now(), docId });
    return docId;
  } catch(e) { console.error('Prediction save error:', e); return null; }
};

// Get a single prediction by name key
window._fbGetPrediction = async function(name) {
  try {
    const docId = name.trim().toLowerCase().replace(/[^a-z0-9]/g,'_');
    const snap = await getDoc(doc(db, PREDS_COL, docId));
    return snap.exists() ? { id: snap.id, ...snap.data() } : null;
  } catch(e) { return null; }
};

window._fbListenPredictions = function(callback) {
  const { collection, onSnapshot: onSnap } = window._fbImports;
  onSnap(collection(db, PREDS_COL), snap => {
    const preds = [];
    snap.forEach(d => preds.push({ id: d.id, ...d.data() }));
    callback(preds);
  });
};

// Store imports for use in predictions
import { collection, onSnapshot as onSnap2 } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
window._fbImports = { collection, onSnapshot: onSnap2 };

// Signal that Firebase is ready
window._fbReady = true;
document.dispatchEvent(new Event('fbReady'));
</script>
<style>
  :root {
    --bg:       #0e1117;
    --surface:  #161b25;
    --card:     #1e2535;
    --border:   #2a3347;
    --accent:   #f5a623;
    --red:      #e84545;
    --green:    #2ecc71;
    --text:     #e8edf5;
    --muted:    #7a8499;
    --bye-bg:   #142010;
    --bye-text: #5dba3a;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    min-height: 100vh;
    overflow-x: auto;
  }

  /* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
  header {
    text-align: center;
    padding: 44px 24px 30px;
    border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, #07090e 0%, var(--bg) 100%);
  }
  .trophy-icon {
    font-size: 2.8rem;
    display: block;
    margin-bottom: 10px;
    filter: drop-shadow(0 0 16px rgba(245,166,35,0.7));
  }
  header h1 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(1.8rem, 4.5vw, 3.5rem);
    letter-spacing: 4px;
    background: linear-gradient(135deg, #f5a623 0%, #f7dc6f 50%, #f5a623 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  header p {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.9rem;
    letter-spacing: 5px;
    text-transform: uppercase;
    color: var(--muted);
    margin-top: 10px;
  }

  /* ‚îÄ‚îÄ Controls ‚îÄ‚îÄ */
  .controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    padding: 12px 28px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
  }
  .legend {
    display: flex;
    gap: 20px;
    align-items: center;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--muted);
  }
  .legend-item { display: flex; align-items: center; gap: 7px; }
  .legend-dot  { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }
  .hint {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 1px;
    color: var(--muted);
    font-style: italic;
  }
  .btn-reset {
    background: transparent;
    border: 1px solid var(--red);
    color: var(--red);
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 6px 18px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.18s;
    white-space: nowrap;
  }
  .btn-reset:hover { background: var(--red); color: #fff; }
  .btn-reshuffle {
    background: transparent;
    border: 1px solid #3d9bd4;
    color: #3d9bd4;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 6px 18px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.18s;
    white-space: nowrap;
  }
  .btn-reshuffle:hover { background: #3d9bd4; color: #fff; }
  .btn-reshuffle:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    pointer-events: none;
  }
  /* ‚îÄ‚îÄ Lock button ‚îÄ‚îÄ */
  .lock-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }
  .btn-lock {
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    transition: transform 0.15s;
  }
  .btn-lock:hover { transform: scale(1.12); }
  .lock-icon {
    font-size: 1.6rem;
    line-height: 1;
    filter: drop-shadow(0 0 4px rgba(245,166,35,0.4));
    transition: all 0.25s;
  }
  .lock-status {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    transition: color 0.25s;
  }
  .lock-area.unlocked .lock-status { color: var(--green); }
  .lock-area.unlocked .lock-icon   { filter: drop-shadow(0 0 6px rgba(46,204,113,0.6)); }

  /* Locked overlay on slots */
  .bracket-locked .team-slot:not(.s-bye):not(.s-empty) {
    cursor: not-allowed;
  }
  /* When unlocked, always show pointer on clickable slots */
  .team-slot:not(.s-bye):not(.s-empty) {
    cursor: pointer;
  }
  .btn-reset:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    pointer-events: none;
  }

  /* Password modal */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 10000;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(4px);
  }
  .modal-overlay.visible { display: flex; }
  .modal-box {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 36px 32px 28px;
    width: 320px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    animation: modalPop 0.2s ease;
  }
  @keyframes modalPop {
    from { transform: scale(0.88); opacity: 0; }
    to   { transform: scale(1);    opacity: 1; }
  }
  .modal-lock-icon { font-size: 2.4rem; margin-bottom: 12px; display: block; }
  .modal-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.4rem;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 6px;
  }
  .modal-sub {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.82rem;
    color: var(--muted);
    letter-spacing: 1px;
    margin-bottom: 20px;
  }
  .modal-input {
    width: 100%;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    font-size: 1rem;
    padding: 10px 14px;
    text-align: center;
    letter-spacing: 3px;
    outline: none;
    transition: border-color 0.18s;
    margin-bottom: 8px;
  }
  .modal-input:focus { border-color: var(--accent); }
  .modal-input.error { border-color: var(--red); animation: shake 0.3s ease; }
  @keyframes shake {
    0%,100% { transform: translateX(0); }
    25%      { transform: translateX(-8px); }
    75%      { transform: translateX(8px); }
  }
  .modal-error {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.78rem;
    color: var(--red);
    letter-spacing: 1px;
    min-height: 18px;
    margin-bottom: 14px;
  }
  .modal-btn {
    width: 100%;
    background: var(--accent);
    border: none;
    border-radius: 6px;
    color: #000;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.1rem;
    letter-spacing: 3px;
    padding: 10px;
    cursor: pointer;
    transition: opacity 0.18s;
  }
  .modal-btn:hover { opacity: 0.85; }
  .modal-cancel {
    display: block;
    margin-top: 12px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.78rem;
    color: var(--muted);
    letter-spacing: 1px;
    cursor: pointer;
    text-decoration: underline;
    background: none;
    border: none;
    width: 100%;
  }
  .modal-cancel:hover { color: var(--text); }


  /* ‚îÄ‚îÄ Bracket wrapper ‚îÄ‚îÄ */
  .bracket-wrapper {
    padding: 36px 32px 100px;
    overflow-x: auto;
  }
  .bracket {
    display: flex;
    align-items: flex-start;
    min-width: max-content;
  }

  /* ‚îÄ‚îÄ Round column ‚îÄ‚îÄ */
  .round-col {
    display: flex;
    flex-direction: column;
    width: 240px;
    flex-shrink: 0;
  }
  .round-header {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.05rem;
    letter-spacing: 3px;
    color: var(--accent);
    text-align: center;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 12px;
  }
  .round-matches {
    display: flex;
    flex-direction: column;
    flex: 1;
  }

  /* ‚îÄ‚îÄ Match block ‚îÄ‚îÄ */
  /* Each match block is positioned so its card is vertically centered
     within the vertical space that corresponds to its paired R1 matches. */
  .match-block {
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 0 10px;
  }

  /* Game label ‚Äî sits above the card, no overlap */
  .game-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.65rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 5px;
    padding-left: 2px;
  }

  /* Match card */
  .match-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 7px;
    overflow: hidden;
    transition: border-color 0.18s, box-shadow 0.18s;
  }
  .match-card:hover {
    border-color: #3a4e6e;
    box-shadow: 0 3px 16px rgba(0,0,0,0.45);
  }

  /* ‚îÄ‚îÄ Team slot ‚îÄ‚îÄ */
  .team-slot {
    padding: 10px 14px;
    min-height: 56px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    position: relative;
    cursor: pointer;
    user-select: none;
    transition: background 0.14s;
  }
  .team-slot + .team-slot {
    border-top: 1px solid var(--border);
  }
  .team-slot:hover:not(.s-bye):not(.s-empty) {
    background: rgba(245,166,35,0.07);
  }
  .team-slot.s-winner { background: rgba(46,204,113,0.1); }
  .team-slot.s-loser  { opacity: 0.35; }
  .team-slot.s-bye    { background: var(--bye-bg); cursor: default; }
  .team-slot.s-empty  { cursor: default; }

  .slot-tag {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--muted);
    line-height: 1;
    margin-bottom: 3px;
  }
  .slot-names {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.92rem;
    font-weight: 600;
    color: var(--text);
    line-height: 1.25;
  }
  .team-slot.s-winner .slot-names { color: var(--green); }
  .team-slot.s-bye    .slot-tag   { color: var(--bye-text); opacity: 0.9; }
  .team-slot.s-bye    .slot-names { color: var(--bye-text); font-weight: 500; font-size: 0.82rem; }
  .team-slot.s-empty  .slot-names { color: var(--muted); font-weight: 400; font-size: 0.82rem; }

  .win-check {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--green);
    font-size: 0.9rem;
    font-weight: 700;
  }

  /* ‚îÄ‚îÄ Connector column ‚îÄ‚îÄ */
  .connector-col {
    width: 40px;
    min-width: 40px;
    flex-shrink: 0;
    align-self: stretch;
    position: relative;
  }

  /* ‚îÄ‚îÄ Champion box ‚îÄ‚îÄ */
  .champion-col {
    width: 420px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .champion-header {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3rem;
    letter-spacing: 4px;
    color: var(--accent);
    margin-bottom: 18px;
    text-align: center;
  }
  .champion-box {
    width: 380px;
    background: linear-gradient(145deg, #15110a, #241c08, #1a1404);
    border: 3px solid var(--accent);
    border-radius: 20px;
    padding: 48px 36px;
    text-align: center;
    box-shadow: 0 0 60px rgba(245,166,35,0.25), 0 0 16px rgba(245,166,35,0.12), inset 0 1px 0 rgba(255,255,255,0.06);
    transition: box-shadow 0.5s, border-color 0.5s;
  }
  .champion-box.crowned {
    box-shadow: 0 0 110px rgba(245,166,35,0.7), 0 0 44px rgba(245,166,35,0.45), 0 0 10px rgba(247,220,111,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
    border-color: #f7dc6f;
    animation: champPulse 2s ease-in-out infinite;
  }
  @keyframes champPulse {
    0%, 100% { box-shadow: 0 0 110px rgba(245,166,35,0.7), 0 0 44px rgba(245,166,35,0.45), inset 0 1px 0 rgba(255,255,255,0.1); }
    50%       { box-shadow: 0 0 150px rgba(245,166,35,0.9), 0 0 70px rgba(245,166,35,0.6), inset 0 1px 0 rgba(255,255,255,0.14); }
  }
  .champ-trophy { font-size: 5rem; display: block; margin-bottom: 20px; filter: drop-shadow(0 0 22px rgba(245,166,35,1)); transition: transform 0.4s; }
  .champ-trophy.pop { animation: trophyBounce 0.65s ease forwards; }
  @keyframes trophyBounce {
    0%   { transform: scale(1); }
    40%  { transform: scale(1.4) rotate(-8deg); }
    70%  { transform: scale(0.9) rotate(4deg); }
    100% { transform: scale(1.15); }
  }
  .champ-label   { font-family: 'Bebas Neue', sans-serif; font-size: 1rem; letter-spacing: 7px; color: var(--accent); }
  .champ-divider { width: 70px; height: 2px; background: linear-gradient(90deg, transparent, var(--accent), transparent); margin: 14px auto; border: none; }
  .champ-team    { font-family: 'Bebas Neue', sans-serif; font-size: 3.2rem; color: #fff; margin-top: 6px; line-height: 1.05; text-shadow: 0 0 24px rgba(245,166,35,0.45); }
  .champ-players { font-size: 1.05rem; color: #c8d0dd; margin-top: 12px; line-height: 1.8; }

  /* scrollbar */
  ::-webkit-scrollbar { height: 5px; width: 5px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  /* ‚îÄ‚îÄ Change picks button ‚îÄ‚îÄ */
  .btn-change-picks {
    width: 100%;
    background: transparent;
    border: 1px solid var(--accent);
    color: var(--accent);
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.85rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 8px;
    border-radius: 5px;
    cursor: pointer;
    margin-top: 10px;
    transition: all 0.15s;
  }
  .btn-change-picks:hover { background: rgba(245,166,35,0.1); }
  .pick-locked-notice {
    background: rgba(46,204,113,0.08);
    border: 1px solid rgba(46,204,113,0.25);
    border-radius: 6px;
    padding: 10px 12px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.82rem;
    color: var(--green);
    letter-spacing: 0.5px;
    line-height: 1.5;
    margin-bottom: 10px;
  }
  .pick-partial-lock {
    background: rgba(245,166,35,0.07);
    border: 1px solid rgba(245,166,35,0.2);
    border-radius: 6px;
    padding: 10px 12px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    color: var(--accent);
    letter-spacing: 0.5px;
    line-height: 1.5;
    margin-bottom: 10px;
  }

  /* ‚îÄ‚îÄ Fire streak badge ‚îÄ‚îÄ */
  .streak-badge {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    font-size: 0.75rem;
    margin-left: 4px;
    animation: flamePulse 0.8s ease-in-out infinite alternate;
    vertical-align: middle;
  }
  @keyframes flamePulse {
    from { transform: scale(1);    filter: drop-shadow(0 0 2px #f5a623); }
    to   { transform: scale(1.18); filter: drop-shadow(0 0 6px #e84545); }
  }

  /* ‚îÄ‚îÄ Page layout (no sidebar, full width) ‚îÄ‚îÄ */
  .page-body {
    display: block;
  }

  /* ‚îÄ‚îÄ Floating action button ‚îÄ‚îÄ */
  .fab-group {
    position: fixed;
    bottom: 28px;
    right: 28px;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 10px;
    z-index: 1000;
  }
  .fab {
    width: 52px;
    height: 52px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.3rem;
    box-shadow: 0 4px 18px rgba(0,0,0,0.5);
    transition: transform 0.18s, box-shadow 0.18s;
  }
  .fab:hover { transform: scale(1.1); box-shadow: 0 6px 24px rgba(0,0,0,0.6); }
  .fab-pick { background: var(--accent); color: #000; }
  .fab-lb   { background: var(--card); color: var(--text); border: 1px solid var(--border); }
  .fab-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.72rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--muted);
    text-align: right;
  }

  /* ‚îÄ‚îÄ Sliding panel (shared) ‚îÄ‚îÄ */
  .slide-panel {
    position: fixed;
    bottom: 0; right: 0;
    width: 380px;
    max-width: 100vw;
    max-height: 90vh;
    background: var(--surface);
    border: 1px solid var(--border);
    border-bottom: none;
    border-radius: 16px 16px 0 0;
    box-shadow: 0 -8px 40px rgba(0,0,0,0.5);
    z-index: 1100;
    display: flex;
    flex-direction: column;
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.4,0,0.2,1);
    overflow: hidden;
  }
  .slide-panel.open { transform: translateY(0); }
  .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px 12px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .panel-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.2rem;
    letter-spacing: 3px;
    color: var(--accent);
  }
  .panel-close {
    background: none;
    border: none;
    color: var(--muted);
    font-size: 1.2rem;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 4px;
    line-height: 1;
    transition: color 0.15s;
  }
  .panel-close:hover { color: var(--text); }
  .panel-body {
    padding: 16px 20px;
    overflow-y: auto;
    flex: 1;
  }

  /* ‚îÄ‚îÄ Prediction form ‚îÄ‚îÄ */
  .pred-mode-tabs {
    display: flex;
    gap: 6px;
    margin-bottom: 14px;
  }
  .pred-tab {
    flex: 1;
    padding: 7px 4px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 1px;
    text-transform: uppercase;
    text-align: center;
    border: 1px solid var(--border);
    border-radius: 5px;
    cursor: pointer;
    color: var(--muted);
    background: transparent;
    transition: all 0.15s;
  }
  .pred-tab.active {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(245,166,35,0.08);
  }
  .pred-input {
    width: 100%;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 5px;
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    font-size: 0.9rem;
    padding: 9px 12px;
    margin-bottom: 12px;
    outline: none;
    transition: border-color 0.15s;
  }
  .pred-input:focus { border-color: var(--accent); }
  .pred-select {
    width: 100%;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 5px;
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    font-size: 0.88rem;
    padding: 9px 12px;
    margin-bottom: 12px;
    outline: none;
    cursor: pointer;
  }
  .pred-btn {
    width: 100%;
    background: var(--accent);
    border: none;
    border-radius: 6px;
    color: #000;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.05rem;
    letter-spacing: 2px;
    padding: 10px;
    cursor: pointer;
    transition: opacity 0.15s;
    margin-top: 4px;
  }
  .pred-btn:hover { opacity: 0.85; }
  .pred-msg {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    text-align: center;
    margin-top: 10px;
    min-height: 18px;
    letter-spacing: 0.5px;
  }
  .pred-msg.success { color: var(--green); }
  .pred-msg.error   { color: var(--red); }

  /* ‚îÄ‚îÄ Round-by-round picker ‚îÄ‚îÄ */
  .rr-progress {
    display: flex;
    gap: 4px;
    margin-bottom: 14px;
    align-items: center;
  }
  .rr-step {
    flex: 1;
    height: 4px;
    border-radius: 2px;
    background: var(--border);
    transition: background 0.2s;
  }
  .rr-step.done    { background: var(--green); }
  .rr-step.current { background: var(--accent); }

  .rr-round-label {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1rem;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 10px;
  }
  .rr-round-sub {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.78rem;
    color: var(--muted);
    letter-spacing: 1px;
    margin-bottom: 12px;
  }
  .rr-matches {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 14px;
  }
  .rr-match {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }
  .rr-match-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    padding: 5px 10px 3px;
    border-bottom: 1px solid var(--border);
  }
  .rr-team-btn {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    background: transparent;
    border: none;
    border-bottom: 1px solid var(--border);
    color: var(--text);
    cursor: pointer;
    transition: background 0.12s;
    text-align: left;
  }
  .rr-team-btn:last-child { border-bottom: none; }
  .rr-team-btn:hover:not(:disabled) { background: rgba(245,166,35,0.07); }
  .rr-team-btn.rr-selected {
    background: rgba(245,166,35,0.13);
    border-left: 3px solid var(--accent);
  }
  .rr-team-btn:disabled { opacity: 0.4; cursor: default; }
  .rr-team-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.65rem;
    color: var(--muted);
    letter-spacing: 1px;
    display: block;
    line-height: 1;
  }
  .rr-team-name {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.92rem;
    font-weight: 600;
    color: var(--text);
    display: block;
    line-height: 1.2;
  }
  .rr-team-btn.rr-selected .rr-team-name { color: var(--accent); }
  .rr-check { margin-left: auto; color: var(--accent); font-size: 1rem; }
  .rr-nav {
    display: flex;
    gap: 8px;
    margin-top: 4px;
  }
  .rr-nav-btn {
    flex: 1;
    padding: 8px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.82rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .rr-nav-btn.prev {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--muted);
  }
  .rr-nav-btn.prev:hover { border-color: var(--text); color: var(--text); }
  .rr-nav-btn.next {
    background: var(--accent);
    border: 1px solid var(--accent);
    color: #000;
  }
  .rr-nav-btn.next:hover { opacity: 0.85; }

  /* ‚îÄ‚îÄ Leaderboard ‚îÄ‚îÄ */
  .leaderboard-list {
    display: flex;
    flex-direction: column;
    gap: 7px;
  }
  .lb-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 9px 12px;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 6px;
  }
  .lb-row.lb-top { border-color: var(--accent); background: rgba(245,166,35,0.07); }
  .lb-rank {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.05rem;
    color: var(--muted);
    width: 22px;
    text-align: center;
    flex-shrink: 0;
  }
  .lb-row.lb-top .lb-rank { color: var(--accent); }
  .lb-name {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.92rem;
    font-weight: 600;
    color: var(--text);
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .lb-score {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.05rem;
    color: var(--green);
    flex-shrink: 0;
  }
  .lb-type {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 1px;
    text-transform: uppercase;
    color: var(--muted);
    flex-shrink: 0;
  }
  .lb-empty {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.85rem;
    color: var(--muted);
    text-align: center;
    padding: 20px 0;
    font-style: italic;
  }
</style>
</head>
<body>

<header>
  <span class="trophy-icon">üèÜ</span>
  <h1>Hardy Diagnostics Cornhole Doubles Tournament 2026</h1>
  <p>Single Elimination &nbsp;¬∑&nbsp; 27 Teams &nbsp;¬∑&nbsp; Random Draw</p>
</header>

<!-- Password Modal -->
<div class="modal-overlay" id="pwModal">
  <div class="modal-box">
    <svg class="modal-lock-icon" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color:var(--accent);margin-bottom:12px;">
      <rect x="3" y="11" width="18" height="11" rx="2" ry="2" fill="rgba(245,166,35,0.12)" stroke="var(--accent)"/>
      <path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="var(--accent)"/>
      <circle cx="12" cy="16" r="1.2" fill="var(--accent)" stroke="none"/>
    </svg>
    <div class="modal-title">Enter Password</div>
    <div class="modal-sub">Admin access required</div>
    <input class="modal-input" id="pwInput" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
      onkeydown="if(event.key==='Enter') submitPassword()" autocomplete="off" />
    <div class="modal-error" id="pwError"></div>
    <button class="modal-btn" onclick="submitPassword()">Unlock</button>
    <button class="modal-cancel" onclick="closeModal()">Cancel</button>
  </div>
</div>

<div class="controls">
  <div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:var(--green)"></div>Winner</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--bye-text)"></div>Bye (auto-advance)</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--muted)"></div>TBD</div>
  </div>
  <span class="hint" id="lockHint">üîí Bracket is locked ‚Äî view only</span>
  <div style="display:flex;align-items:center;gap:14px;">
    <button class="btn-reshuffle" id="reshuffleBtn" onclick="reshuffleBracket()" disabled>‚áÑ Re-Shuffle</button>
    <button class="btn-reset" id="resetBtn" onclick="resetBracket()" disabled>‚Ü∫ Reset Bracket</button>
    <div class="lock-area" id="lockArea">
      <button class="btn-lock" onclick="toggleLock()" title="Lock / Unlock bracket editing">
        <span id="lockIcon">
          <!-- Locked SVG -->
          <svg id="svgLocked" viewBox="0 0 24 24" width="28" height="28" fill="none" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2" fill="rgba(100,120,160,0.18)" stroke="#7a8499"/>
            <path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="#7a8499"/>
            <circle cx="12" cy="16" r="1.3" fill="#7a8499" stroke="none"/>
          </svg>
          <!-- Unlocked SVG -->
          <svg id="svgUnlocked" viewBox="0 0 24 24" width="28" height="28" fill="none" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2" fill="rgba(46,204,113,0.15)" stroke="#2ecc71"/>
            <path d="M7 11V7a5 5 0 0 1 9.9-1" stroke="#2ecc71"/>
            <circle cx="12" cy="16" r="1.3" fill="#2ecc71" stroke="none"/>
          </svg>
        </span>
        <span class="lock-status" id="lockStatus">Locked</span>
      </button>
    </div>
  </div>
</div>

<div class="page-body">
  <div class="bracket-wrapper">
    <div class="bracket" id="bracket"></div>
  </div>
</div>

<!-- ‚îÄ‚îÄ Floating Action Buttons ‚îÄ‚îÄ -->
<div class="fab-group">
  <div style="display:flex;flex-direction:column;align-items:center;gap:4px;">
    <span class="fab-label">Leaderboard</span>
    <button class="fab fab-lb" onclick="togglePanel('lbPanel')" title="Leaderboard">üèÖ</button>
  </div>
  <div style="display:flex;flex-direction:column;align-items:center;gap:4px;">
    <span class="fab-label">Make a Pick</span>
    <button class="fab fab-pick" onclick="togglePanel('pickPanel')" title="Make your pick">üéØ</button>
  </div>
</div>

<!-- ‚îÄ‚îÄ Pick Panel ‚îÄ‚îÄ -->
<div class="slide-panel" id="pickPanel">
  <div class="panel-header">
    <span class="panel-title">üéØ Make Your Pick</span>
    <button class="panel-close" onclick="closePanel('pickPanel')">‚úï</button>
  </div>
  <div class="panel-body">
    <div style="display:flex;gap:8px;margin-bottom:0;">
      <input class="pred-input" id="predName" type="text" placeholder="Enter your name" maxlength="40" style="margin-bottom:0;flex:1;" />
      <button class="pred-btn" style="width:auto;padding:9px 14px;margin-top:0;flex-shrink:0;font-size:0.82rem;" onclick="lookupExistingPick()">Look Up</button>
    </div>
    <div style="height:10px;"></div>
    <div class="pred-mode-tabs">
      <button class="pred-tab active" id="tabChamp" onclick="switchPredTab('champ')">üèÜ Champion Only</button>
      <button class="pred-tab" id="tabFull" onclick="switchPredTab('full')">üìã Full Bracket</button>
    </div>
    <!-- Champion-only mode -->
    <div id="predChampMode">
      <select class="pred-select" id="predChampPick">
        <option value="">-- Pick the winner --</option>
      </select>
    </div>
    <!-- Full bracket round-by-round mode -->
    <div id="predFullMode" style="display:none;">
      <div class="rr-progress" id="rrProgress"></div>
      <div class="rr-round-label" id="rrRoundLabel"></div>
      <div class="rr-round-sub" id="rrRoundSub"></div>
      <div class="rr-matches" id="rrMatches"></div>
      <div class="rr-nav">
        <button class="rr-nav-btn prev" id="rrPrevBtn" onclick="rrNav(-1)">‚Üê Back</button>
        <button class="rr-nav-btn next" id="rrNextBtn" onclick="rrNav(1)">Next ‚Üí</button>
      </div>
    </div>
    <button class="pred-btn" id="predSubmitBtn" onclick="submitPrediction()" style="margin-top:14px;">Submit Pick</button>
    <div class="pred-msg" id="predMsg"></div>
  </div>
</div>

<!-- ‚îÄ‚îÄ Leaderboard Panel ‚îÄ‚îÄ -->
<div class="slide-panel" id="lbPanel">
  <div class="panel-header">
    <span class="panel-title">üèÖ Bracket Prediction Leaderboard</span>
    <button class="panel-close" onclick="closePanel('lbPanel')">‚úï</button>
  </div>
  <div class="panel-body">
    <div class="leaderboard-list" id="leaderboard">
      <div class="lb-empty">No picks submitted yet</div>
    </div>
  </div>
</div>

<script>
/* ‚îÄ‚îÄ‚îÄ TEAMS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const TEAMS = [
  { id:'T1',  label:'Team 1',  p1:'Alani Vasquez',     p2:'Geo Ruiz' },
  { id:'T2',  label:'Team 2',  p1:'Wes Koyama',        p2:'Ernesto Diaz' },
  { id:'T3',  label:'Team 3',  p1:'Byanca Villalba',   p2:'Arturo Villalba' },
  { id:'T4',  label:'Team 4',  p1:'Isaiah Valdez',     p2:'Maria Pimentel' },
  { id:'T5',  label:'Team 5',  p1:'Jezi Morales',      p2:'Jerry Moxley' },
  { id:'T6',  label:'Team 6',  p1:'Michael Bulan',     p2:'Anthony Nunez' },
  { id:'T7',  label:'Team 7',  p1:'Mike Morris',       p2:'Gavin Kelly' },
  { id:'T8',  label:'Team 8',  p1:'Edgar Rodriguez',   p2:'Salvador Diaz' },
  { id:'T9',  label:'Team 9',  p1:'Miles Amby',        p2:'Megan Roesner' },
  { id:'T11', label:'Team 11', p1:'Raymond Carlyle',   p2:'Carlos Cruz' },
  { id:'T12', label:'Team 12', p1:'Sarah Susenbach',   p2:'Gabriella Fuentes' },
  { id:'T13', label:'Team 13', p1:'Brian Tom',         p2:'Kyle Zook' },
  { id:'T14', label:'Team 14', p1:'Frank Ramirez',     p2:'Jaime Pasos' },
  { id:'T15', label:'Team 15', p1:'Victoria Regalado', p2:'Vanessa Ramos-Solorio' },
  { id:'T16', label:'Team 16', p1:'Kelly Blair',       p2:'Arianna Leon' },
  { id:'T17', label:'Team 17', p1:'Anthony Nunez',     p2:'Michael Bulan' },
  { id:'T18', label:'Team 18', p1:'Angel Garcia',      p2:'Manuel Saldivar' },
  { id:'T19', label:'Team 19', p1:'Adam Acosta',       p2:'Daniel Gonzales' },
  { id:'T20', label:'Team 20', p1:'Gabriel Diaz',      p2:'Fabian Juarez' },
  { id:'T21', label:'Team 21', p1:'Nadine Cepeda',     p2:'Joey Gonzalez' },
  { id:'T22', label:'Team 22', p1:'Charles Arandia',   p2:'Emannuel Leon-R' },
  { id:'T23', label:'Team 23', p1:'Jacob Rosseti',     p2:'Mario Corral' },
  { id:'T24', label:'Team 24', p1:'Melissa Evans',     p2:'Alynna Duncan' },
  { id:'T25', label:'Team 25', p1:'Rob Nievez',        p2:'Vanessa Hernandez' },
  { id:'T26', label:'Team 26', p1:'Bobby Ortiz',       p2:'Josiah Guzman' },
  { id:'T27', label:'Team 27', p1:'Daniel Vazquez',    p2:'Susana Estrada' },
];

/* ‚îÄ‚îÄ‚îÄ RNG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function makeRng(seed) {
  let s = seed >>> 0;
  return () => { s = (Math.imul(1664525, s) + 1013904223) >>> 0; return s / 0x100000000; };
}
function shuffle(arr, rng) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
let ST        = null;
let _ignoreNext = false; // prevent echo when we save our own write

function getSeed(savedSeed) {
  // Use seed from Firestore if available, otherwise generate new one
  if (savedSeed) return parseInt(savedSeed);
  return Math.random() * 1e9 | 0;
}

function buildBracket(seedValue) {
  const computedSeed = getSeed(seedValue);
  const rng = makeRng(computedSeed);
  window._currentSeed = computedSeed; // store so we can save to Firestore
  const shuffled = shuffle(TEAMS, rng);

  // 27 teams ‚Üí 32 slots ‚Üí 5 byes.
  // Spread byes evenly: every ~5-6 positions gets a bye.
  // We'll place them at positions 5,11,17,23,29 in the 32-slot array (0-indexed).
  // Then shuffle the non-bye positions randomly.
  // This ensures no two byes are adjacent.
  const BYE_POSITIONS = new Set([4, 10, 16, 22, 28]);
  const slots = new Array(32).fill(null);
  let teamIdx = 0;
  for (let i = 0; i < 32; i++) {
    if (!BYE_POSITIONS.has(i)) slots[i] = shuffled[teamIdx++];
    // BYE positions stay null
  }

  // Build R1: 16 matches
  const r1 = [];
  for (let i = 0; i < 16; i++) {
    const top = slots[i * 2];
    const bot = slots[i * 2 + 1];
    const isByeMatch = top === null || bot === null;
    const autoWinner = top === null ? bot : (bot === null ? top : null);
    r1.push({
      id: `R1G${i+1}`,
      top: top === null ? 'BYE' : top,
      bottom: bot === null ? 'BYE' : bot,
      winner: autoWinner,
      isBye: isByeMatch,
    });
  }

  // Build subsequent rounds
  const rounds = [r1];
  while (rounds[rounds.length-1].length > 1) {
    const prev = rounds[rounds.length-1];
    const rIdx = rounds.length + 1;
    const next = prev.reduce((acc, m, i) => {
      if (i % 2 === 0) {
        acc.push({
          id: `R${rIdx}G${acc.length+1}`,
          top: null, bottom: null, winner: null,
          srcA: prev[i].id, srcB: prev[i+1].id,
        });
      }
      return acc;
    }, []);
    rounds.push(next);
  }

  ST = { rounds };

  // Auto-propagate bye winners
  r1.forEach(m => { if (m.winner) propagate(m.id, m.winner); });

  // Picks are restored separately via Firestore in applyFirestoreState()
}

function findMatch(id) {
  for (const round of ST.rounds)
    for (const m of round)
      if (m.id === id) return m;
  return null;
}

function applyFirestoreState(data) {
  // Rebuild bracket with the saved seed so team order matches
  buildBracket(data.seed);

  // Replay saved picks
  const picks = data.picks || [];
  picks.forEach(({ mid, wid }) => {
    const m = findMatch(mid);
    if (!m) return;
    const team = [m.top, m.bottom].find(t => t && t !== 'BYE' && t.id === wid);
    if (team) { m.winner = team; propagate(mid, team); }
  });

  render();
}

function propagate(srcId, team) {
  for (const round of ST.rounds) {
    for (const m of round) {
      let changed = false;
      if (m.srcA === srcId) { m.top    = team; changed = true; }
      if (m.srcB === srcId) { m.bottom = team; changed = true; }
      // If a winner was already set for this match but no longer matches either slot, clear it
      if (changed && m.winner && m.winner !== 'BYE') {
        const topId = (m.top && m.top !== 'BYE') ? m.top.id : null;
        const botId = (m.bottom && m.bottom !== 'BYE') ? m.bottom.id : null;
        if (m.winner.id !== topId && m.winner.id !== botId) {
          m.winner = null;
          clearDownstream(m.id);
        }
      }
    }
  }
}

function clearDownstream(srcId) {
  for (const round of ST.rounds) {
    for (const m of round) {
      if (m.srcA === srcId) m.top    = null;
      if (m.srcB === srcId) m.bottom = null;
      if ((m.srcA === srcId || m.srcB === srcId) && m.winner) {
        m.winner = null;
        clearDownstream(m.id);
      }
    }
  }
}

function savePicks() {
  if (!window._fbSave) return;
  const picks = ST.rounds.flat()
    .filter(m => m.winner && m.winner !== 'BYE')
    .map(m => ({ mid: m.id, wid: m.winner.id }));
  const data = { seed: String(window._currentSeed), picks };
  _ignoreNext = true;
  window._fbSave(data);
}

/* ‚îÄ‚îÄ‚îÄ LOCK / PASSWORD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const PASSWORD     = 'WellnessPeeps';
const SESSION_MS   = 30 * 60 * 1000; // 30 minutes
let   isUnlocked   = false;
let   lockTimer    = null;

function checkSession() {
  const exp = localStorage.getItem('hd2026_unlock_exp');
  if (exp && Date.now() < parseInt(exp)) {
    applyUnlock();
  }
}

function applyUnlock() {
  isUnlocked = true;
  document.getElementById('svgLocked').style.display   = 'none';
  document.getElementById('svgUnlocked').style.display = '';
  document.getElementById('lockStatus').textContent = 'Unlocked';
  document.getElementById('lockArea').classList.add('unlocked');
  document.getElementById('lockHint').textContent   = 'üîì Bracket editing enabled';
  document.getElementById('resetBtn').disabled      = false;
  document.getElementById('reshuffleBtn').disabled  = false;
  document.getElementById('bracket').classList.remove('bracket-locked');

  // Auto-lock after 30 min
  if (lockTimer) clearTimeout(lockTimer);
  lockTimer = setTimeout(lock, SESSION_MS);
}

function lock() {
  isUnlocked = false;
  localStorage.removeItem('hd2026_unlock_exp');
  if (lockTimer) clearTimeout(lockTimer);
  document.getElementById('svgLocked').style.display   = '';
  document.getElementById('svgUnlocked').style.display = 'none';
  document.getElementById('lockStatus').textContent = 'Locked';
  document.getElementById('lockArea').classList.remove('unlocked');
  document.getElementById('lockHint').textContent   = 'üîí Bracket is locked ‚Äî view only';
  document.getElementById('resetBtn').disabled      = true;
  document.getElementById('reshuffleBtn').disabled  = true;
  document.getElementById('bracket').classList.add('bracket-locked');
}

function toggleLock() {
  if (isUnlocked) {
    lock();
  } else {
    openModal();
  }
}

function openModal() {
  document.getElementById('pwInput').value = '';
  document.getElementById('pwError').textContent = '';
  document.getElementById('pwInput').classList.remove('error');
  document.getElementById('pwModal').classList.add('visible');
  setTimeout(() => document.getElementById('pwInput').focus(), 80);
}

function closeModal() {
  document.getElementById('pwModal').classList.remove('visible');
}

function submitPassword() {
  const val = document.getElementById('pwInput').value;
  if (val === PASSWORD) {
    const exp = Date.now() + SESSION_MS;
    localStorage.setItem('hd2026_unlock_exp', exp);
    closeModal();
    applyUnlock();
  } else {
    const inp = document.getElementById('pwInput');
    inp.classList.remove('error');
    void inp.offsetWidth; // restart animation
    inp.classList.add('error');
    document.getElementById('pwError').textContent = 'Incorrect password. Try again.';
    inp.value = '';
  }
}

// Close modal if clicking outside the box
document.getElementById('pwModal').addEventListener('click', function(e) {
  if (e.target === this) closeModal();
});

/* ‚îÄ‚îÄ‚îÄ CANVAS POLYFILL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    this.beginPath();
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r);
    this.lineTo(x + w, y + h - r);
    this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    this.lineTo(x + r, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r);
    this.lineTo(x, y + r);
    this.quadraticCurveTo(x, y, x + r, y);
    this.closePath();
  };
}

/* ‚îÄ‚îÄ‚îÄ CONFETTI (regular rounds) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const CONFETTI_COLORS = ['#f5a623','#f7dc6f','#2ecc71','#3498db','#e74c3c','#9b59b6','#1abc9c','#ffffff'];

function launchConfetti(originEl) {
  const rect    = originEl.getBoundingClientRect();
  const originX = rect.left + rect.width  / 2;
  const originY = rect.top  + rect.height / 2;

  const canvas = document.createElement('canvas');
  canvas.style.cssText = 'position:fixed;inset:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;';
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  const pieces = Array.from({ length: 55 }, () => {
    const angle = (Math.random() * Math.PI * 1.2) - Math.PI * 0.6;
    const speed = 3 + Math.random() * 6;
    const size  = 5 + Math.random() * 7;
    return {
      x: originX, y: originY,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 5,
      rot: Math.random() * 360, rotV: (Math.random() - 0.5) * 14,
      w: size, h: size * (0.35 + Math.random() * 0.5),
      color: CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)],
      alpha: 1, circle: Math.random() > 0.6,
    };
  });

  let frame = 0;
  const totalFrames = 80;
  function tick() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let anyAlive = false;
    pieces.forEach(p => {
      p.vy += 0.28; p.x += p.vx; p.y += p.vy; p.rot += p.rotV;
      p.alpha = Math.max(0, 1 - frame / totalFrames);
      if (p.alpha > 0.01) anyAlive = true;
      ctx.save(); ctx.globalAlpha = p.alpha;
      ctx.translate(p.x, p.y); ctx.rotate(p.rot * Math.PI / 180);
      ctx.fillStyle = p.color;
      if (p.circle) { ctx.beginPath(); ctx.arc(0,0,p.w/2,0,Math.PI*2); ctx.fill(); }
      else ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    });
    frame++;
    if (anyAlive) requestAnimationFrame(tick); else canvas.remove();
  }
  requestAnimationFrame(tick);
}

/* ‚îÄ‚îÄ‚îÄ FIREWORKS + CORNHOLE BAGS (Championship) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function launchChampionCelebration() {
  // Glow the champion box
  const box = document.getElementById('champBox');
  if (box) box.classList.add('crowned');
  const trophy = document.getElementById('champTrophy');
  if (trophy) { trophy.classList.remove('pop'); void trophy.offsetWidth; trophy.classList.add('pop'); }

  const canvas = document.createElement('canvas');
  canvas.style.cssText = 'position:fixed;inset:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;';
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  const W = canvas.width, H = canvas.height;
  const FW_COLORS = ['#f5a623','#f7dc6f','#e74c3c','#3498db','#2ecc71','#9b59b6','#ff6b9d','#ffffff','#00d2ff'];
  const BAG_COLORS = ['#e74c3c','#3498db','#f5a623','#2ecc71','#9b59b6'];

  let particles = [];
  let rockets   = [];
  let bags      = [];
  let frame     = 0;
  const TOTAL   = 900; // ~15 seconds at 60fps

  function makeRocket() {
    const x = W * (0.15 + Math.random() * 0.7);
    return {
      x, y: H + 10,
      tx: x + (Math.random() - 0.5) * 120,
      ty: H * (0.1 + Math.random() * 0.45),
      speed: 8 + Math.random() * 6,
      color: FW_COLORS[Math.floor(Math.random() * FW_COLORS.length)],
      trail: [],
      exploded: false,
    };
  }

  function explode(rx, ry, color) {
    const count = 80 + Math.floor(Math.random() * 60);
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.3;
      const speed = 2 + Math.random() * 7;
      particles.push({
        x: rx, y: ry,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        color: Math.random() > 0.3 ? color : '#ffffff',
        alpha: 1,
        size: 2 + Math.random() * 3,
        decay: 0.012 + Math.random() * 0.012,
        sparkle: Math.random() > 0.6,
      });
    }
    // Starburst ring
    for (let i = 0; i < 12; i++) {
      const angle = (Math.PI * 2 * i) / 12;
      particles.push({
        x: rx, y: ry,
        vx: Math.cos(angle) * 9,
        vy: Math.sin(angle) * 9,
        color: '#ffffff',
        alpha: 1, size: 3, decay: 0.025, sparkle: false,
      });
    }
  }

  function makeBag() {
    // Bags launched from bottom corners and center, arcing up
    const startX = Math.random() > 0.5 ? W * 0.1 : W * 0.9;
    const color  = BAG_COLORS[Math.floor(Math.random() * BAG_COLORS.length)];
    const angle  = startX < W / 2
      ? -(0.8 + Math.random() * 0.5)   // launched right
      : -(Math.PI - 0.8 - Math.random() * 0.5); // launched left
    const speed  = 14 + Math.random() * 8;
    return {
      x: startX, y: H + 20,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      rot: Math.random() * 360,
      rotV: (Math.random() - 0.5) * 18,
      color, alpha: 1, size: 18 + Math.random() * 10,
      alive: true,
    };
  }

  // Schedule rockets
  const rocketSchedule = [];
  for (let i = 0; i < 30; i++) {
    rocketSchedule.push(Math.floor(Math.random() * (TOTAL - 80)));
  }
  rocketSchedule.sort((a,b) => a - b);

  // Schedule bags
  const bagSchedule = [];
  for (let i = 0; i < 22; i++) {
    bagSchedule.push(Math.floor(Math.random() * (TOTAL - 40)));
  }

  function drawBag(ctx, b) {
    ctx.save();
    ctx.globalAlpha = b.alpha;
    ctx.translate(b.x, b.y);
    ctx.rotate(b.rot * Math.PI / 180);
    // Draw cornhole bag: rounded square with stitching
    const s = b.size;
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.roundRect(-s/2, -s/2, s, s, s * 0.2);
    ctx.fill();
    // Stitching lines
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1.2;
    ctx.strokeRect(-s/2 + s*0.15, -s/2 + s*0.15, s*0.7, s*0.7);
    // Center dot
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(0, 0, s * 0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function tick() {
    ctx.clearRect(0, 0, W, H);

    // Launch rockets on schedule
    if (rocketSchedule.length && frame >= rocketSchedule[0]) {
      rockets.push(makeRocket());
      rocketSchedule.shift();
    }
    // Launch bags on schedule
    if (bagSchedule.length && frame >= bagSchedule[0]) {
      bags.push(makeBag());
      bagSchedule.shift();
    }

    // Update & draw rockets
    rockets = rockets.filter(r => {
      if (r.exploded) return false;
      const dx = r.tx - r.x, dy = r.ty - r.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < r.speed) {
        explode(r.x, r.y, r.color);
        // Flash
        ctx.fillStyle = 'rgba(255,255,255,0.18)';
        ctx.fillRect(0,0,W,H);
        r.exploded = true;
        return false;
      }
      r.trail.push({ x: r.x, y: r.y });
      if (r.trail.length > 12) r.trail.shift();
      r.x += (dx / dist) * r.speed;
      r.y += (dy / dist) * r.speed;
      // Draw trail
      r.trail.forEach((pt, i) => {
        ctx.save();
        ctx.globalAlpha = (i / r.trail.length) * 0.6;
        ctx.fillStyle = r.color;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
      // Draw rocket head
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(r.x, r.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      return true;
    });

    // Update & draw particles
    particles = particles.filter(p => {
      p.vx *= 0.97; p.vy *= 0.97; p.vy += 0.08;
      p.x += p.vx; p.y += p.vy;
      p.alpha = Math.max(0, p.alpha - p.decay);
      if (p.alpha < 0.01) return false;
      ctx.save();
      ctx.globalAlpha = p.sparkle ? p.alpha * (0.5 + 0.5 * Math.sin(frame * 0.4)) : p.alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      return true;
    });

    // Update & draw bags
    bags = bags.filter(b => {
      b.vx *= 0.995;
      b.vy += 0.45; // gravity
      b.x  += b.vx;
      b.y  += b.vy;
      b.rot += b.rotV;
      // Fade when off screen
      if (b.y > H + 60) { b.alive = false; return false; }
      b.alpha = Math.min(1, Math.max(0, 1 - (frame / TOTAL) * 0.5));
      drawBag(ctx, b);
      return b.alive;
    });

    frame++;
    if (frame < TOTAL) requestAnimationFrame(tick);
    else canvas.remove();
  }

  requestAnimationFrame(tick);
}

/* ‚îÄ‚îÄ‚îÄ INTERACTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function clickSlot(matchId, slot) {
  if (!isUnlocked) return; // bracket is locked
  const m = findMatch(matchId);
  if (!m) return;
  const team = slot === 'top' ? m.top : m.bottom;
  if (!team || team === 'BYE') return;

  if (m.winner?.id === team.id) {
    m.winner = null;
    clearDownstream(matchId);
    savePicks();
    render();
  } else {
    m.winner = team;
    propagate(matchId, team);
    savePicks();
    render();

    // Fire confetti from the winning slot after DOM updates
    requestAnimationFrame(() => {
      const card = document.querySelector(`[data-id="${matchId}"]`);
      const slotEls = card ? card.querySelectorAll('.team-slot') : [];
      const origin  = slotEls[slot === 'top' ? 0 : 1] || card || document.getElementById('bracket');
      const isChamp = ST.rounds[ST.rounds.length - 1][0]?.id === matchId;
      if (isChamp) launchChampionCelebration();
      else launchConfetti(origin);
    });
  }
}

function resetBracket() {
  if (!isUnlocked) return;
  if (!confirm('Reset bracket progression? Team matchups will stay the same, but all results will be cleared.')) return;
  // Rebuild with the SAME seed ‚Äî keeps team order, clears all picks
  buildBracket(window._currentSeed);
  render();
  if (window._fbSave) {
    _ignoreNext = true;
    window._fbSave({ seed: String(window._currentSeed), picks: [] });
  }
}

function reshuffleBracket() {
  if (!isUnlocked) return;
  if (!confirm('Re-shuffle teams? This will randomize all matchups and clear all results.')) return;
  // Build with NO seed ‚Äî generates a brand new random seed
  buildBracket();
  render();
  if (window._fbSave) {
    _ignoreNext = true;
    window._fbSave({ seed: String(window._currentSeed), picks: [] });
  }
}

/* ‚îÄ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
const ROUND_NAMES = ['Round 1', 'Round 2', 'Quarterfinals', 'Semifinals', 'Championship'];

// Fixed heights (px) ‚Äî consistent across all rounds
const SLOT_H    = 56;   // height of one team slot
const MATCH_H   = SLOT_H * 2 + 1; // match card total height
const LABEL_H   = 24;  // game label height
const GAP_R1    = 20;  // gap between match blocks in R1
// Full height one R1 match block occupies in the column:
const BLOCK_H   = LABEL_H + MATCH_H + GAP_R1;

function render() {
  const el = document.getElementById('bracket');
  el.innerHTML = '';

  ST.rounds.forEach((round, ri) => {
    // Each match in round ri spans 2^ri R1 blocks vertically
    const span      = Math.pow(2, ri);
    const blockSpan = span * BLOCK_H; // total height for this match

    const col = document.createElement('div');
    col.className = 'round-col';

    // Header
    const hdr = document.createElement('div');
    hdr.className = 'round-header';
    hdr.textContent = ROUND_NAMES[ri] || `Round ${ri+1}`;
    col.appendChild(hdr);

    // Matches
    const matchesEl = document.createElement('div');
    matchesEl.className = 'round-matches';

    round.forEach((match, mi) => {
      const block = document.createElement('div');
      block.className = 'match-block';
      block.style.height = `${blockSpan}px`;

      // Game label
      const lbl = document.createElement('div');
      lbl.className = 'game-label';
      lbl.textContent = `Game ${mi + 1}`;
      block.appendChild(lbl);

      // Card
      const card = document.createElement('div');
      card.className = 'match-card';
      card.setAttribute('data-id', match.id);
      card.appendChild(buildSlot(match, 'top'));
      card.appendChild(buildSlot(match, 'bottom'));
      block.appendChild(card);

      matchesEl.appendChild(block);
    });

    col.appendChild(matchesEl);
    el.appendChild(col);

    // After last round: add connector + champion box inline
    if (ri < ST.rounds.length - 1) {
      const conn = document.createElement('div');
      conn.className = 'connector-col';
      conn.setAttribute('data-ri', ri);
      el.appendChild(conn);
    } else {
      // This is the final round ‚Äî add a short connector then champion box
      const finalConn = document.createElement('div');
      finalConn.className = 'connector-col';
      finalConn.setAttribute('data-ri', ri);
      finalConn.setAttribute('data-final', '1');
      el.appendChild(finalConn);

      const finalWinner = ST.rounds[ST.rounds.length - 1][0]?.winner;
      const champCol = document.createElement('div');
      champCol.className = 'champion-col';

      // Vertically center the champion box relative to the final match
      const finalSpan = Math.pow(2, ri) * BLOCK_H;
      champCol.style.height = `${finalSpan}px`;
      champCol.style.paddingTop = '40px'; // offset for round header

      champCol.innerHTML = `
        <div class="champion-header">üèÜ Champion</div>
        <div class="champion-box" id="champBox">
          <span class="champ-trophy" id="champTrophy">üèÜ</span>
          <div class="champ-label">Tournament Champion</div>
          <hr class="champ-divider">
          <div class="champ-team">${finalWinner ? finalWinner.label : 'TBD'}</div>
          <div class="champ-players">${finalWinner ? `${finalWinner.p1}<br>${finalWinner.p2}` : '<span style="color:var(--muted);font-size:0.82rem;">Awaiting finalist</span>'}</div>
        </div>`;
      el.appendChild(champCol);
    }
  });

  setTimeout(drawConnectors, 40);
}

/* ‚îÄ‚îÄ‚îÄ STREAK CALCULATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function getTeamWinCount(teamId) {
  let count = 0;
  for (const round of ST.rounds) {
    for (const m of round) {
      if (m.winner && m.winner !== 'BYE' && m.winner.id === teamId) {
        // Only count non-bye wins
        const opponentSlot = m.top?.id === teamId ? m.bottom : m.top;
        if (opponentSlot && opponentSlot !== 'BYE') count++;
      }
    }
  }
  return count;
}

function buildSlot(match, slot) {
  const raw      = slot === 'top' ? match.top : match.bottom;
  // Normalize: treat undefined/null as empty, 'BYE' string as bye, anything else as a team object
  const isBye    = raw === 'BYE';
  const isEmpty  = raw === null || raw === undefined;
  const team     = (!isBye && !isEmpty) ? raw : null;
  const isWinner = team && match.winner && match.winner !== 'BYE' && match.winner.id === team.id;
  const isLoser  = team && match.winner && match.winner !== 'BYE' && match.winner.id !== team.id;

  const div = document.createElement('div');
  div.className = 'team-slot' +
    (isBye    ? ' s-bye'    : '') +
    (isEmpty  ? ' s-empty'  : '') +
    (isWinner ? ' s-winner' : '') +
    (isLoser  ? ' s-loser'  : '');
  div.style.minHeight = `${SLOT_H}px`;

  if (isBye) {
    div.innerHTML = `<div class="slot-tag">Bye</div><div class="slot-names">Auto-Advance ‚úì</div>`;
  } else if (isEmpty) {
    div.innerHTML = `<div class="slot-names">TBD</div>`;
  } else {
    const wins = getTeamWinCount(team.id);
    const fireHTML = wins >= 2 ? `<span class="streak-badge" title="${wins} wins in a row!">üî•${wins >= 3 ? wins : ''}</span>` : '';
    div.innerHTML = `
      <div class="slot-tag">${team.label}</div>
      <div class="slot-names">${team.p1} &amp; ${team.p2} ${fireHTML}</div>
      ${isWinner ? '<span class="win-check">‚úì</span>' : ''}`;
    div.addEventListener('click', () => clickSlot(match.id, slot));
    div.title = `Click to advance ${team.label}`;
  }

  return div;
}

/* ‚îÄ‚îÄ‚îÄ SVG CONNECTORS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function drawConnectors() {
  document.querySelectorAll('.connector-svg').forEach(e => e.remove());

  const bracketEl  = document.getElementById('bracket');
  const roundCols  = [...bracketEl.querySelectorAll('.round-col')];
  const connCols   = [...bracketEl.querySelectorAll('.connector-col')];

  connCols.forEach((col, ri) => {
    const fromCol = roundCols[ri];
    const toCol   = roundCols[ri + 1];
    if (!fromCol || !toCol) return;

    const fromCards = [...fromCol.querySelectorAll('.match-card')];
    const toCards   = [...toCol.querySelectorAll('.match-card')];

    const colRect = col.getBoundingClientRect();
    if (colRect.height < 1) return;

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.classList.add('connector-svg');
    svg.style.cssText = `position:absolute;top:0;left:0;width:${colRect.width}px;height:${colRect.height}px;overflow:visible;pointer-events:none;`;
    col.appendChild(svg);

    const COLOR = '#2e3d55';
    const W     = '1.5';

    function ln(x1, y1, x2, y2) {
      const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      l.setAttribute('x1', x1); l.setAttribute('y1', y1);
      l.setAttribute('x2', x2); l.setAttribute('y2', y2);
      l.setAttribute('stroke', COLOR); l.setAttribute('stroke-width', W);
      l.setAttribute('stroke-linecap', 'round');
      svg.appendChild(l);
    }

    toCards.forEach((toCard, i) => {
      const c1 = fromCards[i * 2];
      const c2 = fromCards[i * 2 + 1];
      if (!c1 || !c2 || !toCard) return;

      const top   = colRect.top;
      const y1    = c1.getBoundingClientRect().top    + c1.getBoundingClientRect().height / 2 - top;
      const y2    = c2.getBoundingClientRect().top    + c2.getBoundingClientRect().height / 2 - top;
      const yn    = toCard.getBoundingClientRect().top + toCard.getBoundingClientRect().height / 2 - top;
      const ymid  = (y1 + y2) / 2;
      const xL    = 0;
      const xMid  = colRect.width / 2;
      const xR    = colRect.width;

      ln(xL,   y1,   xMid, y1);    // left card top ‚Üí midpoint
      ln(xL,   y2,   xMid, y2);    // left card bottom ‚Üí midpoint
      ln(xMid, y1,   xMid, y2);    // vertical bridge
      ln(xMid, ymid, xR,   ymid);  // center ‚Üí right
    });
  });
}

window.addEventListener('resize', () => { drawConnectors(); });

/* ‚îÄ‚îÄ‚îÄ PANEL CONTROLS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
function togglePanel(id) {
  const panel = document.getElementById(id);
  const isOpen = panel.classList.contains('open');
  // Close all panels first
  document.querySelectorAll('.slide-panel').forEach(p => p.classList.remove('open'));
  if (!isOpen) panel.classList.add('open');
}
function closePanel(id) {
  document.getElementById(id).classList.remove('open');
}
// NOTE: No click-outside listener ‚Äî panels only close via the X button

/* ‚îÄ‚îÄ‚îÄ PREDICTIONS & LEADERBOARD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
let predMode       = 'champ';
let fullPicks      = {};       // matchId ‚Üí teamId
let rrRound        = 0;        // current round index in round-by-round picker
let allPreds       = [];
let myDocId        = null;     // Firestore doc ID for current user's prediction
let isEditMode     = false;    // true when editing an existing submission

const RNAMES = ['Round 1','Round 2','Quarterfinals','Semifinals','Championship'];

function switchPredTab(mode) {
  predMode = mode;
  document.getElementById('tabChamp').classList.toggle('active', mode === 'champ');
  document.getElementById('tabFull').classList.toggle('active', mode === 'full');
  document.getElementById('predChampMode').style.display = mode === 'champ' ? '' : 'none';
  document.getElementById('predFullMode').style.display  = mode === 'full'  ? '' : 'none';
  if (mode === 'full') { rrRound = 0; renderRRRound(); }
}

function populateChampSelect() {
  const sel = document.getElementById('predChampPick');
  if (!sel) return;
  const cur = sel.value;
  sel.innerHTML = '<option value="">-- Pick the winner --</option>';
  TEAMS.forEach(t => {
    const opt = document.createElement('option');
    opt.value = t.id;
    opt.textContent = `${t.label}: ${t.p1} & ${t.p2}`;
    sel.appendChild(opt);
  });
  if (cur) sel.value = cur;
}

/* ‚îÄ‚îÄ Round-by-round picker ‚îÄ‚îÄ */
function renderRRRound() {
  if (!ST) return;
  const rounds = ST.rounds;
  const totalRounds = rounds.length;

  // Progress bar
  const prog = document.getElementById('rrProgress');
  if (prog) {
    prog.innerHTML = '';
    rounds.forEach((_, i) => {
      const s = document.createElement('div');
      s.className = 'rr-step' + (i < rrRound ? ' done' : i === rrRound ? ' current' : '');
      prog.appendChild(s);
    });
  }

  const round  = rounds[rrRound];
  const lbl    = document.getElementById('rrRoundLabel');
  const sub    = document.getElementById('rrRoundSub');
  const matchC = document.getElementById('rrMatches');
  if (!lbl || !sub || !matchC) return;

  lbl.textContent = RNAMES[rrRound] || `Round ${rrRound + 1}`;

  // Count how many picks are needed vs made in this round
  const pickable = round.filter(m => {
    const top = m.top; const bot = m.bottom;
    return top && top !== 'BYE' && bot && bot !== 'BYE';
  });
  const picked = pickable.filter(m => fullPicks[m.id]);
  sub.textContent = `${picked.length} of ${pickable.length} picked`;

  matchC.innerHTML = '';
  round.forEach((match, mi) => {
    const topRaw = match.top;
    const botRaw = match.bottom;
    const topBye = topRaw === 'BYE' || topRaw === null || topRaw === undefined;
    const botBye = botRaw === 'BYE' || botRaw === null || botRaw === undefined;

    // If both are unknown/bye, skip
    if (topBye && botBye) return;

    const card = document.createElement('div');
    card.className = 'rr-match';

    const mlabel = document.createElement('div');
    mlabel.className = 'rr-match-label';
    mlabel.textContent = `Game ${mi + 1}`;
    card.appendChild(mlabel);

    [[topRaw, topBye], [botRaw, botBye]].forEach(([raw, isBye]) => {
      const btn = document.createElement('button');
      btn.className = 'rr-team-btn';

      if (isBye || raw === null || raw === undefined) {
        btn.disabled = true;
        btn.innerHTML = `<span class="rr-team-name" style="color:var(--muted);font-style:italic;">TBD / BYE</span>`;
      } else {
        const isSelected = fullPicks[match.id] === raw.id;
        if (isSelected) btn.classList.add('rr-selected');
        const locked = isMatchLocked(match.id);
        if (locked) btn.disabled = true;
        const lockedBadge = locked ? '<span style="font-size:0.65rem;color:var(--muted);margin-left:auto;">üîí Locked</span>' : '';
        btn.innerHTML = `
          <div>
            <span class="rr-team-label">${raw.label}</span>
            <span class="rr-team-name">${raw.p1} &amp; ${raw.p2}</span>
          </div>
          ${isSelected ? '<span class="rr-check">‚úì</span>' : lockedBadge}`;
        if (!locked) {
          btn.addEventListener('click', () => {
            fullPicks[match.id] = raw.id;
            renderRRRound();
          });
        }
      }
      card.appendChild(btn);
    });

    matchC.appendChild(card);
  });

  // Nav buttons
  const prevBtn = document.getElementById('rrPrevBtn');
  const nextBtn = document.getElementById('rrNextBtn');
  if (prevBtn) prevBtn.style.display = rrRound === 0 ? 'none' : '';
  if (nextBtn) {
    if (rrRound === totalRounds - 1) {
      nextBtn.textContent = '‚úì Done';
      nextBtn.onclick = () => {
        document.getElementById('predFullMode').style.display = 'none';
        document.getElementById('predSubmitBtn').scrollIntoView({ behavior: 'smooth' });
      };
    } else {
      nextBtn.textContent = 'Next ‚Üí';
      nextBtn.onclick = () => rrNav(1);
    }
  }
}

function rrNav(dir) {
  if (!ST) return;
  rrRound = Math.max(0, Math.min(ST.rounds.length - 1, rrRound + dir));
  document.getElementById('predFullMode').style.display = '';
  renderRRRound();
}

async function lookupExistingPick() {
  const name  = document.getElementById('predName').value.trim();
  const msgEl = document.getElementById('predMsg');
  if (!name) { msgEl.className = 'pred-msg error'; msgEl.textContent = 'Enter your name first.'; return; }
  msgEl.className = 'pred-msg'; msgEl.textContent = 'Looking up...';

  // Try stable doc ID first
  let existing = await window._fbGetPrediction?.(name);

  // Fallback: search allPreds in memory (catches old docs with timestamp suffix)
  if (!existing && allPreds.length > 0) {
    existing = allPreds.find(p => p.name?.trim().toLowerCase() === name.toLowerCase()) || null;
    if (existing) {
      // Migrate: re-save under stable doc ID so future lookups work
      myDocId    = existing.docId || existing.id;
      isEditMode = true;
      const picks = existing.picks;
      if (picks?.type === 'champ') {
        switchPredTab('champ');
        document.getElementById('predChampPick').value = picks.champId || '';
      } else if (picks?.type === 'full') {
        switchPredTab('full');
        fullPicks = { ...picks.matchPicks };
        renderRRRound();
      }
      const locked = countLockedPicks(picks);
      msgEl.className = 'pred-msg success';
      msgEl.innerHTML = locked > 0
        ? `<span style="color:var(--accent)">‚úé Editing your pick ‚Äî ${locked} match${locked>1?'es':''} already locked.</span>`
        : '‚úé Found your pick! Make changes and click Update.';
      document.getElementById('predSubmitBtn').textContent = 'Update Pick';
      return;
    }
  }

  if (existing) {
    await loadExistingPick(name);
  } else {
    isEditMode = false; myDocId = null;
    msgEl.className = 'pred-msg'; msgEl.textContent = 'No existing pick found ‚Äî enter a new one below.';
    document.getElementById('predSubmitBtn').textContent = 'Submit Pick';
  }
}

// Check if a match is "locked" (result already confirmed in bracket)
function isMatchLocked(matchId) {
  if (!ST) return false;
  const m = findMatch(matchId);
  return !!(m && m.winner && m.winner !== 'BYE');
}

// Returns how many of a user's picks are now locked (can't be changed)
function countLockedPicks(existingPicks) {
  if (!existingPicks || existingPicks.type !== 'full') return 0;
  return Object.entries(existingPicks.matchPicks || {}).filter(([mid]) => isMatchLocked(mid)).length;
}

// Load an existing prediction into the form for editing
async function loadExistingPick(name) {
  if (!window._fbGetPrediction) return;
  const existing = await window._fbGetPrediction(name);
  if (!existing) return;

  myDocId    = existing.docId || existing.id;
  isEditMode = true;
  const picks = existing.picks;

  // Restore pick type
  if (picks.type === 'champ') {
    switchPredTab('champ');
    document.getElementById('predChampPick').value = picks.champId || '';
  } else {
    switchPredTab('full');
    fullPicks = { ...picks.matchPicks };
    renderRRRound();
  }

  // Show edit notice
  const locked = countLockedPicks(picks);
  const msgEl  = document.getElementById('predMsg');
  if (locked > 0) {
    msgEl.className = 'pred-msg';
    msgEl.innerHTML = `<span style="color:var(--accent)">‚úé Editing your pick ‚Äî ${locked} match${locked>1?'es':''} are locked and can no longer be changed.</span>`;
  } else {
    msgEl.className = 'pred-msg success';
    msgEl.textContent = '‚úé Editing your existing pick.';
  }
  document.getElementById('predSubmitBtn').textContent = 'Update Pick';
}

async function submitPrediction() {
  const name  = document.getElementById('predName').value.trim();
  const msgEl = document.getElementById('predMsg');
  msgEl.className = 'pred-msg';
  msgEl.textContent = '';

  if (!name) { msgEl.className = 'pred-msg error'; msgEl.textContent = 'Please enter your name.'; return; }

  // Block duplicate submissions ‚Äî must Look Up first to edit
  if (!isEditMode) {
    msgEl.textContent = 'Checking for existing pick...';
    const existing = await window._fbGetPrediction?.(name)
      || allPreds.find(p => p.name?.trim().toLowerCase() === name.toLowerCase())
      || null;
    if (existing) {
      msgEl.className = 'pred-msg error';
      msgEl.innerHTML = `You already have a pick under <strong>${name}</strong>. Click <strong>Look Up</strong> to load and edit it.`;
      return;
    }
  }

  let picks = {};
  if (predMode === 'champ') {
    const champId = document.getElementById('predChampPick').value;
    if (!champId) { msgEl.className = 'pred-msg error'; msgEl.textContent = 'Please pick a champion.'; return; }

    // If the championship match is already decided, champion pick is locked
    const finalMatch = ST?.rounds[ST.rounds.length - 1][0];
    if (finalMatch?.winner && finalMatch.winner !== 'BYE') {
      msgEl.className = 'pred-msg error';
      msgEl.textContent = 'The champion has already been decided ‚Äî this pick is locked.';
      return;
    }
    picks = { type: 'champ', champId };
  } else {
    if (Object.keys(fullPicks).length === 0) {
      msgEl.className = 'pred-msg error'; msgEl.textContent = 'Make at least one pick.'; return;
    }

    // Merge: keep existing locked picks, allow changes to unlocked ones
    let finalMatchPicks = { ...fullPicks };
    if (isEditMode && myDocId) {
      // Re-fetch existing to preserve any locked picks that weren't in fullPicks
      const existing = await window._fbGetPrediction(name);
      if (existing?.picks?.matchPicks) {
        Object.entries(existing.picks.matchPicks).forEach(([mid, wid]) => {
          if (isMatchLocked(mid)) {
            finalMatchPicks[mid] = wid; // always preserve locked picks
          }
        });
      }
    }
    picks = { type: 'full', matchPicks: finalMatchPicks };
  }

  const wasEditing = isEditMode;
  msgEl.textContent = 'Saving...';
  const savedId = await window._fbSavePrediction(name, picks, myDocId);
  if (savedId) {
    myDocId    = savedId;
    isEditMode = true;
    msgEl.className = 'pred-msg success';
    msgEl.textContent = wasEditing ? '‚úì Pick updated! Good luck!' : '‚úì Pick submitted! Good luck!';
    document.getElementById('predSubmitBtn').textContent = 'Update Pick';
    if (!wasEditing) {
      // Fresh submit ‚Äî clear form except name so they can see it's locked in
      document.getElementById('predChampPick').value = picks.champId || '';
    }
    fullPicks = {};
    rrRound = 0;
    if (predMode === 'full') renderRRRound();
  } else {
    msgEl.className = 'pred-msg error';
    msgEl.textContent = 'Error saving. Try again.';
  }
}

function scorePrediction(pred) {
  if (!ST) return 0;
  const picks = pred.picks;
  if (!picks) return 0;
  let score = 0;
  if (picks.type === 'champ') {
    const finalMatch = ST.rounds[ST.rounds.length - 1][0];
    if (finalMatch?.winner && finalMatch.winner !== 'BYE' && finalMatch.winner.id === picks.champId) score = 1;
  } else if (picks.type === 'full') {
    ST.rounds.flat().forEach(match => {
      if (match.winner && match.winner !== 'BYE') {
        if (picks.matchPicks?.[match.id] === match.winner.id) score++;
      }
    });
  }
  return score;
}

function updateLeaderboard(preds) {
  allPreds = preds;
  const lb = document.getElementById('leaderboard');
  if (!lb) return;
  if (!preds || preds.length === 0) {
    lb.innerHTML = '<div class="lb-empty">No picks yet ‚Äî be the first!</div>';
    return;
  }
  const scored = preds.map(p => ({
    name: p.name,
    type: p.picks?.type === 'full' ? 'Full' : 'Champ',
    score: scorePrediction(p),
    submittedAt: p.submittedAt || 0,
  })).sort((a,b) => b.score - a.score || a.submittedAt - b.submittedAt);

  lb.innerHTML = '';
  scored.forEach((entry, i) => {
    const row = document.createElement('div');
    row.className = 'lb-row' + (i === 0 && entry.score > 0 ? ' lb-top' : '');
    const medals = ['ü•á','ü•à','ü•â'];
    row.innerHTML = `
      <span class="lb-rank">${i < 3 ? medals[i] : i+1}</span>
      <span class="lb-name">${entry.name}</span>
      <span class="lb-type">${entry.type}</span>
      <span class="lb-score">${entry.score}pt${entry.score !== 1 ? 's' : ''}</span>`;
    lb.appendChild(row);
  });
}

/* ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
// Show a loading state while Firebase connects
document.getElementById('bracket').innerHTML =
  '<div style="padding:60px;text-align:center;color:var(--muted);font-family:Barlow Condensed,sans-serif;font-size:1.1rem;letter-spacing:2px;">CONNECTING TO LIVE BRACKET...</div>';

function initApp(firestoreData) {
  if (firestoreData) {
    applyFirestoreState(firestoreData);
  } else {
    // No data in Firestore yet ‚Äî build fresh and save
    buildBracket();
    render();
    if (window._fbSave) {
      window._fbSave({ seed: String(window._currentSeed), picks: [] });
    }
  }

  checkSession();
  document.getElementById('bracket').classList.add('bracket-locked');
  populateChampSelect();

  // ‚îÄ‚îÄ Real-time bracket listener ‚îÄ‚îÄ
  if (window._fbListen) {
    window._fbListen(data => {
      if (_ignoreNext) { _ignoreNext = false; return; }
      applyFirestoreState(data);
      if (!isUnlocked) document.getElementById('bracket').classList.add('bracket-locked');
      // Re-score leaderboard with updated bracket state
      updateLeaderboard(allPreds);
      if (predMode === 'full') renderMiniPicks();
    });
  }

  // ‚îÄ‚îÄ Real-time predictions listener ‚îÄ‚îÄ
  if (window._fbListenPredictions) {
    window._fbListenPredictions(preds => {
      updateLeaderboard(preds);
    });
  }
}

// Wait for Firebase to be ready, then load state
if (window._fbReady) {
  window._fbGet().then(initApp);
} else {
  document.addEventListener('fbReady', () => {
    window._fbGet().then(initApp);
  });
}
</script>
</body>
</html>
