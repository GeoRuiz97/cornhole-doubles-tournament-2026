<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Hardy Diagnostics Cornhole Doubles Tournament 2026</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Barlow+Condensed:wght@400;600;700&family=Barlow:wght@400;500&display=swap" rel="stylesheet">
<!-- Firebase SDKs -->
<script type="module">
import { initializeApp }                        from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, setDoc, onSnapshot, getDoc }
                                                from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

const firebaseConfig = {
  apiKey:            "AIzaSyAyT1KNeWPEbhCSAO5K33iQmwBjHMw_awE",
  authDomain:        "cornholedoublestournament-2026.firebaseapp.com",
  projectId:         "cornholedoublestournament-2026",
  storageBucket:     "cornholedoublestournament-2026.firebasestorage.app",
  messagingSenderId: "998672163064",
  appId:             "1:998672163064:web:1789a449b9f75c1201db0d"
};

const app = initializeApp(firebaseConfig);
const db  = getFirestore(app);
const BRACKET_DOC = doc(db, 'bracket', 'state');

// â”€â”€ Expose Firebase helpers to global scope so non-module code can call them â”€â”€
window._fbSave = async function(data) {
  try { await setDoc(BRACKET_DOC, data); } catch(e) { console.error('Firestore save error:', e); }
};

window._fbListen = function(callback) {
  onSnapshot(BRACKET_DOC, snap => {
    if (snap.exists()) callback(snap.data());
  });
};

window._fbGet = async function() {
  try {
    const snap = await getDoc(BRACKET_DOC);
    return snap.exists() ? snap.data() : null;
  } catch(e) { console.error('Firestore get error:', e); return null; }
};

// Signal that Firebase is ready
window._fbReady = true;
document.dispatchEvent(new Event('fbReady'));
</script>
<style>
  :root {
    --bg:       #0e1117;
    --surface:  #161b25;
    --card:     #1e2535;
    --border:   #2a3347;
    --accent:   #f5a623;
    --red:      #e84545;
    --green:    #2ecc71;
    --text:     #e8edf5;
    --muted:    #7a8499;
    --bye-bg:   #142010;
    --bye-text: #5dba3a;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    min-height: 100vh;
    overflow-x: auto;
  }

  /* â”€â”€ Header â”€â”€ */
  header {
    text-align: center;
    padding: 44px 24px 30px;
    border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, #07090e 0%, var(--bg) 100%);
  }
  .trophy-icon {
    font-size: 2.8rem;
    display: block;
    margin-bottom: 10px;
    filter: drop-shadow(0 0 16px rgba(245,166,35,0.7));
  }
  header h1 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(1.8rem, 4.5vw, 3.5rem);
    letter-spacing: 4px;
    background: linear-gradient(135deg, #f5a623 0%, #f7dc6f 50%, #f5a623 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  header p {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.9rem;
    letter-spacing: 5px;
    text-transform: uppercase;
    color: var(--muted);
    margin-top: 10px;
  }

  /* â”€â”€ Controls â”€â”€ */
  .controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    padding: 12px 28px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
  }
  .legend {
    display: flex;
    gap: 20px;
    align-items: center;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--muted);
  }
  .legend-item { display: flex; align-items: center; gap: 7px; }
  .legend-dot  { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }
  .hint {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 1px;
    color: var(--muted);
    font-style: italic;
  }
  .btn-reset {
    background: transparent;
    border: 1px solid var(--red);
    color: var(--red);
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 6px 18px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.18s;
    white-space: nowrap;
  }
  .btn-reset:hover { background: var(--red); color: #fff; }
  .btn-reshuffle {
    background: transparent;
    border: 1px solid #3d9bd4;
    color: #3d9bd4;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.8rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    padding: 6px 18px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.18s;
    white-space: nowrap;
  }
  .btn-reshuffle:hover { background: #3d9bd4; color: #fff; }
  .btn-reshuffle:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    pointer-events: none;
  }
  /* â”€â”€ Lock button â”€â”€ */
  .lock-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }
  .btn-lock {
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 4px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    transition: transform 0.15s;
  }
  .btn-lock:hover { transform: scale(1.12); }
  .lock-icon {
    font-size: 1.6rem;
    line-height: 1;
    filter: drop-shadow(0 0 4px rgba(245,166,35,0.4));
    transition: all 0.25s;
  }
  .lock-status {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    transition: color 0.25s;
  }
  .lock-area.unlocked .lock-status { color: var(--green); }
  .lock-area.unlocked .lock-icon   { filter: drop-shadow(0 0 6px rgba(46,204,113,0.6)); }

  /* Locked overlay on slots */
  .bracket-locked .team-slot:not(.s-bye):not(.s-empty) {
    cursor: not-allowed;
  }
  /* When unlocked, always show pointer on clickable slots */
  .team-slot:not(.s-bye):not(.s-empty) {
    cursor: pointer;
  }
  .btn-reset:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    pointer-events: none;
  }

  /* Password modal */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 10000;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(4px);
  }
  .modal-overlay.visible { display: flex; }
  .modal-box {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 36px 32px 28px;
    width: 320px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    animation: modalPop 0.2s ease;
  }
  @keyframes modalPop {
    from { transform: scale(0.88); opacity: 0; }
    to   { transform: scale(1);    opacity: 1; }
  }
  .modal-lock-icon { font-size: 2.4rem; margin-bottom: 12px; display: block; }
  .modal-title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.4rem;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 6px;
  }
  .modal-sub {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.82rem;
    color: var(--muted);
    letter-spacing: 1px;
    margin-bottom: 20px;
  }
  .modal-input {
    width: 100%;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-family: 'Barlow', sans-serif;
    font-size: 1rem;
    padding: 10px 14px;
    text-align: center;
    letter-spacing: 3px;
    outline: none;
    transition: border-color 0.18s;
    margin-bottom: 8px;
  }
  .modal-input:focus { border-color: var(--accent); }
  .modal-input.error { border-color: var(--red); animation: shake 0.3s ease; }
  @keyframes shake {
    0%,100% { transform: translateX(0); }
    25%      { transform: translateX(-8px); }
    75%      { transform: translateX(8px); }
  }
  .modal-error {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.78rem;
    color: var(--red);
    letter-spacing: 1px;
    min-height: 18px;
    margin-bottom: 14px;
  }
  .modal-btn {
    width: 100%;
    background: var(--accent);
    border: none;
    border-radius: 6px;
    color: #000;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.1rem;
    letter-spacing: 3px;
    padding: 10px;
    cursor: pointer;
    transition: opacity 0.18s;
  }
  .modal-btn:hover { opacity: 0.85; }
  .modal-cancel {
    display: block;
    margin-top: 12px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.78rem;
    color: var(--muted);
    letter-spacing: 1px;
    cursor: pointer;
    text-decoration: underline;
    background: none;
    border: none;
    width: 100%;
  }
  .modal-cancel:hover { color: var(--text); }


  /* â”€â”€ Bracket wrapper â”€â”€ */
  .bracket-wrapper {
    padding: 36px 32px 100px;
    overflow-x: auto;
  }
  .bracket {
    display: flex;
    align-items: flex-start;
    min-width: max-content;
  }

  /* â”€â”€ Round column â”€â”€ */
  .round-col {
    display: flex;
    flex-direction: column;
    width: 240px;
    flex-shrink: 0;
  }
  .round-header {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.05rem;
    letter-spacing: 3px;
    color: var(--accent);
    text-align: center;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 12px;
  }
  .round-matches {
    display: flex;
    flex-direction: column;
    flex: 1;
  }

  /* â”€â”€ Match block â”€â”€ */
  /* Each match block is positioned so its card is vertically centered
     within the vertical space that corresponds to its paired R1 matches. */
  .match-block {
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 0 10px;
  }

  /* Game label â€” sits above the card, no overlap */
  .game-label {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.65rem;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 5px;
    padding-left: 2px;
  }

  /* Match card */
  .match-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 7px;
    overflow: hidden;
    transition: border-color 0.18s, box-shadow 0.18s;
  }
  .match-card:hover {
    border-color: #3a4e6e;
    box-shadow: 0 3px 16px rgba(0,0,0,0.45);
  }

  /* â”€â”€ Team slot â”€â”€ */
  .team-slot {
    padding: 10px 14px;
    min-height: 56px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    position: relative;
    cursor: pointer;
    user-select: none;
    transition: background 0.14s;
  }
  .team-slot + .team-slot {
    border-top: 1px solid var(--border);
  }
  .team-slot:hover:not(.s-bye):not(.s-empty) {
    background: rgba(245,166,35,0.07);
  }
  .team-slot.s-winner { background: rgba(46,204,113,0.1); }
  .team-slot.s-loser  { opacity: 0.35; }
  .team-slot.s-bye    { background: var(--bye-bg); cursor: default; }
  .team-slot.s-empty  { cursor: default; }

  .slot-tag {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.62rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    color: var(--muted);
    line-height: 1;
    margin-bottom: 3px;
  }
  .slot-names {
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.92rem;
    font-weight: 600;
    color: var(--text);
    line-height: 1.25;
  }
  .team-slot.s-winner .slot-names { color: var(--green); }
  .team-slot.s-bye    .slot-tag   { color: var(--bye-text); opacity: 0.9; }
  .team-slot.s-bye    .slot-names { color: var(--bye-text); font-weight: 500; font-size: 0.82rem; }
  .team-slot.s-empty  .slot-names { color: var(--muted); font-weight: 400; font-size: 0.82rem; }

  .win-check {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--green);
    font-size: 0.9rem;
    font-weight: 700;
  }

  /* â”€â”€ Connector column â”€â”€ */
  .connector-col {
    width: 40px;
    min-width: 40px;
    flex-shrink: 0;
    align-self: stretch;
    position: relative;
  }

  /* â”€â”€ Champion box â”€â”€ */
  .champion-col {
    width: 420px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .champion-header {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3rem;
    letter-spacing: 4px;
    color: var(--accent);
    margin-bottom: 18px;
    text-align: center;
  }
  .champion-box {
    width: 380px;
    background: linear-gradient(145deg, #15110a, #241c08, #1a1404);
    border: 3px solid var(--accent);
    border-radius: 20px;
    padding: 48px 36px;
    text-align: center;
    box-shadow: 0 0 60px rgba(245,166,35,0.25), 0 0 16px rgba(245,166,35,0.12), inset 0 1px 0 rgba(255,255,255,0.06);
    transition: box-shadow 0.5s, border-color 0.5s;
  }
  .champion-box.crowned {
    box-shadow: 0 0 110px rgba(245,166,35,0.7), 0 0 44px rgba(245,166,35,0.45), 0 0 10px rgba(247,220,111,0.5), inset 0 1px 0 rgba(255,255,255,0.1);
    border-color: #f7dc6f;
    animation: champPulse 2s ease-in-out infinite;
  }
  @keyframes champPulse {
    0%, 100% { box-shadow: 0 0 110px rgba(245,166,35,0.7), 0 0 44px rgba(245,166,35,0.45), inset 0 1px 0 rgba(255,255,255,0.1); }
    50%       { box-shadow: 0 0 150px rgba(245,166,35,0.9), 0 0 70px rgba(245,166,35,0.6), inset 0 1px 0 rgba(255,255,255,0.14); }
  }
  .champ-trophy { font-size: 5rem; display: block; margin-bottom: 20px; filter: drop-shadow(0 0 22px rgba(245,166,35,1)); transition: transform 0.4s; }
  .champ-trophy.pop { animation: trophyBounce 0.65s ease forwards; }
  @keyframes trophyBounce {
    0%   { transform: scale(1); }
    40%  { transform: scale(1.4) rotate(-8deg); }
    70%  { transform: scale(0.9) rotate(4deg); }
    100% { transform: scale(1.15); }
  }
  .champ-label   { font-family: 'Bebas Neue', sans-serif; font-size: 1rem; letter-spacing: 7px; color: var(--accent); }
  .champ-divider { width: 70px; height: 2px; background: linear-gradient(90deg, transparent, var(--accent), transparent); margin: 14px auto; border: none; }
  .champ-team    { font-family: 'Bebas Neue', sans-serif; font-size: 3.2rem; color: #fff; margin-top: 6px; line-height: 1.05; text-shadow: 0 0 24px rgba(245,166,35,0.45); }
  .champ-players { font-size: 1.05rem; color: #c8d0dd; margin-top: 12px; line-height: 1.8; }

  /* scrollbar */
  ::-webkit-scrollbar { height: 5px; width: 5px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>

<header>
  <span class="trophy-icon">ğŸ†</span>
  <h1>Hardy Diagnostics Cornhole Doubles Tournament 2026</h1>
  <p>Single Elimination &nbsp;Â·&nbsp; 27 Teams &nbsp;Â·&nbsp; Random Draw</p>
</header>

<!-- Password Modal -->
<div class="modal-overlay" id="pwModal">
  <div class="modal-box">
    <svg class="modal-lock-icon" viewBox="0 0 24 24" width="48" height="48" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color:var(--accent);margin-bottom:12px;">
      <rect x="3" y="11" width="18" height="11" rx="2" ry="2" fill="rgba(245,166,35,0.12)" stroke="var(--accent)"/>
      <path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="var(--accent)"/>
      <circle cx="12" cy="16" r="1.2" fill="var(--accent)" stroke="none"/>
    </svg>
    <div class="modal-title">Enter Password</div>
    <div class="modal-sub">Admin access required</div>
    <input class="modal-input" id="pwInput" type="password" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
      onkeydown="if(event.key==='Enter') submitPassword()" autocomplete="off" />
    <div class="modal-error" id="pwError"></div>
    <button class="modal-btn" onclick="submitPassword()">Unlock</button>
    <button class="modal-cancel" onclick="closeModal()">Cancel</button>
  </div>
</div>

<div class="controls">
  <div class="legend">
    <div class="legend-item"><div class="legend-dot" style="background:var(--green)"></div>Winner</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--bye-text)"></div>Bye (auto-advance)</div>
    <div class="legend-item"><div class="legend-dot" style="background:var(--muted)"></div>TBD</div>
  </div>
  <span class="hint" id="lockHint">ğŸ”’ Bracket is locked â€” view only</span>
  <div style="display:flex;align-items:center;gap:14px;">
    <button class="btn-reshuffle" id="reshuffleBtn" onclick="reshuffleBracket()" disabled>â‡„ Re-Shuffle</button>
    <button class="btn-reset" id="resetBtn" onclick="resetBracket()" disabled>â†º Reset Bracket</button>
    <div class="lock-area" id="lockArea">
      <button class="btn-lock" onclick="toggleLock()" title="Lock / Unlock bracket editing">
        <span id="lockIcon">
          <!-- Locked SVG -->
          <svg id="svgLocked" viewBox="0 0 24 24" width="28" height="28" fill="none" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2" fill="rgba(100,120,160,0.18)" stroke="#7a8499"/>
            <path d="M7 11V7a5 5 0 0 1 10 0v4" stroke="#7a8499"/>
            <circle cx="12" cy="16" r="1.3" fill="#7a8499" stroke="none"/>
          </svg>
          <!-- Unlocked SVG -->
          <svg id="svgUnlocked" viewBox="0 0 24 24" width="28" height="28" fill="none" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
            <rect x="3" y="11" width="18" height="11" rx="2" ry="2" fill="rgba(46,204,113,0.15)" stroke="#2ecc71"/>
            <path d="M7 11V7a5 5 0 0 1 9.9-1" stroke="#2ecc71"/>
            <circle cx="12" cy="16" r="1.3" fill="#2ecc71" stroke="none"/>
          </svg>
        </span>
        <span class="lock-status" id="lockStatus">Locked</span>
      </button>
    </div>
  </div>
</div>

<div class="bracket-wrapper">
  <div class="bracket" id="bracket"></div>
</div>

<script>
/* â”€â”€â”€ TEAMS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const TEAMS = [
  { id:'T1',  label:'Team 1',  p1:'Alani Vasquez',     p2:'Geo Ruiz' },
  { id:'T2',  label:'Team 2',  p1:'Wes Koyama',        p2:'Ernesto Diaz' },
  { id:'T3',  label:'Team 3',  p1:'Byanca Villalba',   p2:'Arturo Villalba' },
  { id:'T4',  label:'Team 4',  p1:'Isaiah Valdez',     p2:'Maria Pimentel' },
  { id:'T5',  label:'Team 5',  p1:'Jezi Morales',      p2:'Jerry Moxley' },
  { id:'T6',  label:'Team 6',  p1:'Michael Bulan',     p2:'Anthony Nunez' },
  { id:'T7',  label:'Team 7',  p1:'Mike Morris',       p2:'Gavin Kelly' },
  { id:'T8',  label:'Team 8',  p1:'Edgar Rodriguez',   p2:'Salvador Diaz' },
  { id:'T9',  label:'Team 9',  p1:'Miles Amby',        p2:'Megan Roesner' },
  { id:'T11', label:'Team 11', p1:'Raymond Carlyle',   p2:'Carlos Cruz' },
  { id:'T12', label:'Team 12', p1:'Sarah Susenbach',   p2:'Gabriella Fuentes' },
  { id:'T13', label:'Team 13', p1:'Brian Tom',         p2:'Kyle Zook' },
  { id:'T14', label:'Team 14', p1:'Frank Ramirez',     p2:'Jaime Pasos' },
  { id:'T15', label:'Team 15', p1:'Victoria Regalado', p2:'Vanessa Ramos-Solorio' },
  { id:'T16', label:'Team 16', p1:'Kelly Blair',       p2:'Arianna Leon' },
  { id:'T17', label:'Team 17', p1:'Anthony Nunez',     p2:'Michael Bulan' },
  { id:'T18', label:'Team 18', p1:'Angel Garcia',      p2:'Manuel Saldivar' },
  { id:'T19', label:'Team 19', p1:'Adam Acosta',       p2:'Daniel Gonzales' },
  { id:'T20', label:'Team 20', p1:'Gabriel Diaz',      p2:'Fabian Juarez' },
  { id:'T21', label:'Team 21', p1:'Nadine Cepeda',     p2:'Joey Gonzalez' },
  { id:'T22', label:'Team 22', p1:'Charles Arandia',   p2:'Emannuel Leon-R' },
  { id:'T23', label:'Team 23', p1:'Jacob Rosseti',     p2:'Mario Corral' },
  { id:'T24', label:'Team 24', p1:'Melissa Evans',     p2:'Alynna Duncan' },
  { id:'T25', label:'Team 25', p1:'Rob Nievez',        p2:'Vanessa Hernandez' },
  { id:'T26', label:'Team 26', p1:'Bobby Ortiz',       p2:'Josiah Guzman' },
  { id:'T27', label:'Team 27', p1:'Daniel Vazquez',    p2:'Susana Estrada' },
];

/* â”€â”€â”€ RNG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function makeRng(seed) {
  let s = seed >>> 0;
  return () => { s = (Math.imul(1664525, s) + 1013904223) >>> 0; return s / 0x100000000; };
}
function shuffle(arr, rng) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

/* â”€â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
let ST        = null;
let _ignoreNext = false; // prevent echo when we save our own write

function getSeed(savedSeed) {
  // Use seed from Firestore if available, otherwise generate new one
  if (savedSeed) return parseInt(savedSeed);
  return Math.random() * 1e9 | 0;
}

function buildBracket(seedValue) {
  const computedSeed = getSeed(seedValue);
  const rng = makeRng(computedSeed);
  window._currentSeed = computedSeed; // store so we can save to Firestore
  const shuffled = shuffle(TEAMS, rng);

  // 27 teams â†’ 32 slots â†’ 5 byes.
  // Spread byes evenly: every ~5-6 positions gets a bye.
  // We'll place them at positions 5,11,17,23,29 in the 32-slot array (0-indexed).
  // Then shuffle the non-bye positions randomly.
  // This ensures no two byes are adjacent.
  const BYE_POSITIONS = new Set([4, 10, 16, 22, 28]);
  const slots = new Array(32).fill(null);
  let teamIdx = 0;
  for (let i = 0; i < 32; i++) {
    if (!BYE_POSITIONS.has(i)) slots[i] = shuffled[teamIdx++];
    // BYE positions stay null
  }

  // Build R1: 16 matches
  const r1 = [];
  for (let i = 0; i < 16; i++) {
    const top = slots[i * 2];
    const bot = slots[i * 2 + 1];
    const isByeMatch = top === null || bot === null;
    const autoWinner = top === null ? bot : (bot === null ? top : null);
    r1.push({
      id: `R1G${i+1}`,
      top: top === null ? 'BYE' : top,
      bottom: bot === null ? 'BYE' : bot,
      winner: autoWinner,
      isBye: isByeMatch,
    });
  }

  // Build subsequent rounds
  const rounds = [r1];
  while (rounds[rounds.length-1].length > 1) {
    const prev = rounds[rounds.length-1];
    const rIdx = rounds.length + 1;
    const next = prev.reduce((acc, m, i) => {
      if (i % 2 === 0) {
        acc.push({
          id: `R${rIdx}G${acc.length+1}`,
          top: null, bottom: null, winner: null,
          srcA: prev[i].id, srcB: prev[i+1].id,
        });
      }
      return acc;
    }, []);
    rounds.push(next);
  }

  ST = { rounds };

  // Auto-propagate bye winners
  r1.forEach(m => { if (m.winner) propagate(m.id, m.winner); });

  // Picks are restored separately via Firestore in applyFirestoreState()
}

function findMatch(id) {
  for (const round of ST.rounds)
    for (const m of round)
      if (m.id === id) return m;
  return null;
}

function applyFirestoreState(data) {
  // Rebuild bracket with the saved seed so team order matches
  buildBracket(data.seed);

  // Replay saved picks
  const picks = data.picks || [];
  picks.forEach(({ mid, wid }) => {
    const m = findMatch(mid);
    if (!m) return;
    const team = [m.top, m.bottom].find(t => t && t !== 'BYE' && t.id === wid);
    if (team) { m.winner = team; propagate(mid, team); }
  });

  render();
}

function propagate(srcId, team) {
  for (const round of ST.rounds) {
    for (const m of round) {
      let changed = false;
      if (m.srcA === srcId) { m.top    = team; changed = true; }
      if (m.srcB === srcId) { m.bottom = team; changed = true; }
      // If a winner was already set for this match but no longer matches either slot, clear it
      if (changed && m.winner && m.winner !== 'BYE') {
        const topId = (m.top && m.top !== 'BYE') ? m.top.id : null;
        const botId = (m.bottom && m.bottom !== 'BYE') ? m.bottom.id : null;
        if (m.winner.id !== topId && m.winner.id !== botId) {
          m.winner = null;
          clearDownstream(m.id);
        }
      }
    }
  }
}

function clearDownstream(srcId) {
  for (const round of ST.rounds) {
    for (const m of round) {
      if (m.srcA === srcId) m.top    = null;
      if (m.srcB === srcId) m.bottom = null;
      if ((m.srcA === srcId || m.srcB === srcId) && m.winner) {
        m.winner = null;
        clearDownstream(m.id);
      }
    }
  }
}

function savePicks() {
  if (!window._fbSave) return;
  const picks = ST.rounds.flat()
    .filter(m => m.winner && m.winner !== 'BYE')
    .map(m => ({ mid: m.id, wid: m.winner.id }));
  const data = { seed: String(window._currentSeed), picks };
  _ignoreNext = true;
  window._fbSave(data);
}

/* â”€â”€â”€ LOCK / PASSWORD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const PASSWORD     = 'WellnessPeeps';
const SESSION_MS   = 30 * 60 * 1000; // 30 minutes
let   isUnlocked   = false;
let   lockTimer    = null;

function checkSession() {
  const exp = localStorage.getItem('hd2026_unlock_exp');
  if (exp && Date.now() < parseInt(exp)) {
    applyUnlock();
  }
}

function applyUnlock() {
  isUnlocked = true;
  document.getElementById('svgLocked').style.display   = 'none';
  document.getElementById('svgUnlocked').style.display = '';
  document.getElementById('lockStatus').textContent = 'Unlocked';
  document.getElementById('lockArea').classList.add('unlocked');
  document.getElementById('lockHint').textContent   = 'ğŸ”“ Bracket editing enabled';
  document.getElementById('resetBtn').disabled      = false;
  document.getElementById('reshuffleBtn').disabled  = false;
  document.getElementById('bracket').classList.remove('bracket-locked');

  // Auto-lock after 30 min
  if (lockTimer) clearTimeout(lockTimer);
  lockTimer = setTimeout(lock, SESSION_MS);
}

function lock() {
  isUnlocked = false;
  localStorage.removeItem('hd2026_unlock_exp');
  if (lockTimer) clearTimeout(lockTimer);
  document.getElementById('svgLocked').style.display   = '';
  document.getElementById('svgUnlocked').style.display = 'none';
  document.getElementById('lockStatus').textContent = 'Locked';
  document.getElementById('lockArea').classList.remove('unlocked');
  document.getElementById('lockHint').textContent   = 'ğŸ”’ Bracket is locked â€” view only';
  document.getElementById('resetBtn').disabled      = true;
  document.getElementById('reshuffleBtn').disabled  = true;
  document.getElementById('bracket').classList.add('bracket-locked');
}

function toggleLock() {
  if (isUnlocked) {
    lock();
  } else {
    openModal();
  }
}

function openModal() {
  document.getElementById('pwInput').value = '';
  document.getElementById('pwError').textContent = '';
  document.getElementById('pwInput').classList.remove('error');
  document.getElementById('pwModal').classList.add('visible');
  setTimeout(() => document.getElementById('pwInput').focus(), 80);
}

function closeModal() {
  document.getElementById('pwModal').classList.remove('visible');
}

function submitPassword() {
  const val = document.getElementById('pwInput').value;
  if (val === PASSWORD) {
    const exp = Date.now() + SESSION_MS;
    localStorage.setItem('hd2026_unlock_exp', exp);
    closeModal();
    applyUnlock();
  } else {
    const inp = document.getElementById('pwInput');
    inp.classList.remove('error');
    void inp.offsetWidth; // restart animation
    inp.classList.add('error');
    document.getElementById('pwError').textContent = 'Incorrect password. Try again.';
    inp.value = '';
  }
}

// Close modal if clicking outside the box
document.getElementById('pwModal').addEventListener('click', function(e) {
  if (e.target === this) closeModal();
});

/* â”€â”€â”€ CANVAS POLYFILL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    this.beginPath();
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r);
    this.lineTo(x + w, y + h - r);
    this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    this.lineTo(x + r, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r);
    this.lineTo(x, y + r);
    this.quadraticCurveTo(x, y, x + r, y);
    this.closePath();
  };
}

/* â”€â”€â”€ CONFETTI (regular rounds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const CONFETTI_COLORS = ['#f5a623','#f7dc6f','#2ecc71','#3498db','#e74c3c','#9b59b6','#1abc9c','#ffffff'];

function launchConfetti(originEl) {
  const rect    = originEl.getBoundingClientRect();
  const originX = rect.left + rect.width  / 2;
  const originY = rect.top  + rect.height / 2;

  const canvas = document.createElement('canvas');
  canvas.style.cssText = 'position:fixed;inset:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;';
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  const pieces = Array.from({ length: 55 }, () => {
    const angle = (Math.random() * Math.PI * 1.2) - Math.PI * 0.6;
    const speed = 3 + Math.random() * 6;
    const size  = 5 + Math.random() * 7;
    return {
      x: originX, y: originY,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 5,
      rot: Math.random() * 360, rotV: (Math.random() - 0.5) * 14,
      w: size, h: size * (0.35 + Math.random() * 0.5),
      color: CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)],
      alpha: 1, circle: Math.random() > 0.6,
    };
  });

  let frame = 0;
  const totalFrames = 80;
  function tick() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let anyAlive = false;
    pieces.forEach(p => {
      p.vy += 0.28; p.x += p.vx; p.y += p.vy; p.rot += p.rotV;
      p.alpha = Math.max(0, 1 - frame / totalFrames);
      if (p.alpha > 0.01) anyAlive = true;
      ctx.save(); ctx.globalAlpha = p.alpha;
      ctx.translate(p.x, p.y); ctx.rotate(p.rot * Math.PI / 180);
      ctx.fillStyle = p.color;
      if (p.circle) { ctx.beginPath(); ctx.arc(0,0,p.w/2,0,Math.PI*2); ctx.fill(); }
      else ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    });
    frame++;
    if (anyAlive) requestAnimationFrame(tick); else canvas.remove();
  }
  requestAnimationFrame(tick);
}

/* â”€â”€â”€ FIREWORKS + CORNHOLE BAGS (Championship) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function launchChampionCelebration() {
  // Glow the champion box
  const box = document.getElementById('champBox');
  if (box) box.classList.add('crowned');
  const trophy = document.getElementById('champTrophy');
  if (trophy) { trophy.classList.remove('pop'); void trophy.offsetWidth; trophy.classList.add('pop'); }

  const canvas = document.createElement('canvas');
  canvas.style.cssText = 'position:fixed;inset:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;';
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  const W = canvas.width, H = canvas.height;
  const FW_COLORS = ['#f5a623','#f7dc6f','#e74c3c','#3498db','#2ecc71','#9b59b6','#ff6b9d','#ffffff','#00d2ff'];
  const BAG_COLORS = ['#e74c3c','#3498db','#f5a623','#2ecc71','#9b59b6'];

  let particles = [];
  let rockets   = [];
  let bags      = [];
  let frame     = 0;
  const TOTAL   = 900; // ~15 seconds at 60fps

  function makeRocket() {
    const x = W * (0.15 + Math.random() * 0.7);
    return {
      x, y: H + 10,
      tx: x + (Math.random() - 0.5) * 120,
      ty: H * (0.1 + Math.random() * 0.45),
      speed: 8 + Math.random() * 6,
      color: FW_COLORS[Math.floor(Math.random() * FW_COLORS.length)],
      trail: [],
      exploded: false,
    };
  }

  function explode(rx, ry, color) {
    const count = 80 + Math.floor(Math.random() * 60);
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.3;
      const speed = 2 + Math.random() * 7;
      particles.push({
        x: rx, y: ry,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        color: Math.random() > 0.3 ? color : '#ffffff',
        alpha: 1,
        size: 2 + Math.random() * 3,
        decay: 0.012 + Math.random() * 0.012,
        sparkle: Math.random() > 0.6,
      });
    }
    // Starburst ring
    for (let i = 0; i < 12; i++) {
      const angle = (Math.PI * 2 * i) / 12;
      particles.push({
        x: rx, y: ry,
        vx: Math.cos(angle) * 9,
        vy: Math.sin(angle) * 9,
        color: '#ffffff',
        alpha: 1, size: 3, decay: 0.025, sparkle: false,
      });
    }
  }

  function makeBag() {
    // Bags launched from bottom corners and center, arcing up
    const startX = Math.random() > 0.5 ? W * 0.1 : W * 0.9;
    const color  = BAG_COLORS[Math.floor(Math.random() * BAG_COLORS.length)];
    const angle  = startX < W / 2
      ? -(0.8 + Math.random() * 0.5)   // launched right
      : -(Math.PI - 0.8 - Math.random() * 0.5); // launched left
    const speed  = 14 + Math.random() * 8;
    return {
      x: startX, y: H + 20,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      rot: Math.random() * 360,
      rotV: (Math.random() - 0.5) * 18,
      color, alpha: 1, size: 18 + Math.random() * 10,
      alive: true,
    };
  }

  // Schedule rockets
  const rocketSchedule = [];
  for (let i = 0; i < 30; i++) {
    rocketSchedule.push(Math.floor(Math.random() * (TOTAL - 80)));
  }
  rocketSchedule.sort((a,b) => a - b);

  // Schedule bags
  const bagSchedule = [];
  for (let i = 0; i < 22; i++) {
    bagSchedule.push(Math.floor(Math.random() * (TOTAL - 40)));
  }

  function drawBag(ctx, b) {
    ctx.save();
    ctx.globalAlpha = b.alpha;
    ctx.translate(b.x, b.y);
    ctx.rotate(b.rot * Math.PI / 180);
    // Draw cornhole bag: rounded square with stitching
    const s = b.size;
    ctx.fillStyle = b.color;
    ctx.beginPath();
    ctx.roundRect(-s/2, -s/2, s, s, s * 0.2);
    ctx.fill();
    // Stitching lines
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 1.2;
    ctx.strokeRect(-s/2 + s*0.15, -s/2 + s*0.15, s*0.7, s*0.7);
    // Center dot
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(0, 0, s * 0.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  function tick() {
    ctx.clearRect(0, 0, W, H);

    // Launch rockets on schedule
    if (rocketSchedule.length && frame >= rocketSchedule[0]) {
      rockets.push(makeRocket());
      rocketSchedule.shift();
    }
    // Launch bags on schedule
    if (bagSchedule.length && frame >= bagSchedule[0]) {
      bags.push(makeBag());
      bagSchedule.shift();
    }

    // Update & draw rockets
    rockets = rockets.filter(r => {
      if (r.exploded) return false;
      const dx = r.tx - r.x, dy = r.ty - r.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < r.speed) {
        explode(r.x, r.y, r.color);
        // Flash
        ctx.fillStyle = 'rgba(255,255,255,0.18)';
        ctx.fillRect(0,0,W,H);
        r.exploded = true;
        return false;
      }
      r.trail.push({ x: r.x, y: r.y });
      if (r.trail.length > 12) r.trail.shift();
      r.x += (dx / dist) * r.speed;
      r.y += (dy / dist) * r.speed;
      // Draw trail
      r.trail.forEach((pt, i) => {
        ctx.save();
        ctx.globalAlpha = (i / r.trail.length) * 0.6;
        ctx.fillStyle = r.color;
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
      // Draw rocket head
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(r.x, r.y, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      return true;
    });

    // Update & draw particles
    particles = particles.filter(p => {
      p.vx *= 0.97; p.vy *= 0.97; p.vy += 0.08;
      p.x += p.vx; p.y += p.vy;
      p.alpha = Math.max(0, p.alpha - p.decay);
      if (p.alpha < 0.01) return false;
      ctx.save();
      ctx.globalAlpha = p.sparkle ? p.alpha * (0.5 + 0.5 * Math.sin(frame * 0.4)) : p.alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      return true;
    });

    // Update & draw bags
    bags = bags.filter(b => {
      b.vx *= 0.995;
      b.vy += 0.45; // gravity
      b.x  += b.vx;
      b.y  += b.vy;
      b.rot += b.rotV;
      // Fade when off screen
      if (b.y > H + 60) { b.alive = false; return false; }
      b.alpha = Math.min(1, Math.max(0, 1 - (frame / TOTAL) * 0.5));
      drawBag(ctx, b);
      return b.alive;
    });

    frame++;
    if (frame < TOTAL) requestAnimationFrame(tick);
    else canvas.remove();
  }

  requestAnimationFrame(tick);
}

/* â”€â”€â”€ INTERACTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function clickSlot(matchId, slot) {
  if (!isUnlocked) return; // bracket is locked
  const m = findMatch(matchId);
  if (!m) return;
  const team = slot === 'top' ? m.top : m.bottom;
  if (!team || team === 'BYE') return;

  if (m.winner?.id === team.id) {
    m.winner = null;
    clearDownstream(matchId);
    savePicks();
    render();
  } else {
    m.winner = team;
    propagate(matchId, team);
    savePicks();
    render();

    // Fire confetti from the winning slot after DOM updates
    requestAnimationFrame(() => {
      const card = document.querySelector(`[data-id="${matchId}"]`);
      const slotEls = card ? card.querySelectorAll('.team-slot') : [];
      const origin  = slotEls[slot === 'top' ? 0 : 1] || card || document.getElementById('bracket');
      const isChamp = ST.rounds[ST.rounds.length - 1][0]?.id === matchId;
      if (isChamp) launchChampionCelebration();
      else launchConfetti(origin);
    });
  }
}

function resetBracket() {
  if (!isUnlocked) return;
  if (!confirm('Reset bracket progression? Team matchups will stay the same, but all results will be cleared.')) return;
  // Rebuild with the SAME seed â€” keeps team order, clears all picks
  buildBracket(window._currentSeed);
  render();
  if (window._fbSave) {
    _ignoreNext = true;
    window._fbSave({ seed: String(window._currentSeed), picks: [] });
  }
}

function reshuffleBracket() {
  if (!isUnlocked) return;
  if (!confirm('Re-shuffle teams? This will randomize all matchups and clear all results.')) return;
  // Build with NO seed â€” generates a brand new random seed
  buildBracket();
  render();
  if (window._fbSave) {
    _ignoreNext = true;
    window._fbSave({ seed: String(window._currentSeed), picks: [] });
  }
}

/* â”€â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
const ROUND_NAMES = ['Round 1', 'Round 2', 'Quarterfinals', 'Semifinals', 'Championship'];

// Fixed heights (px) â€” consistent across all rounds
const SLOT_H    = 56;   // height of one team slot
const MATCH_H   = SLOT_H * 2 + 1; // match card total height
const LABEL_H   = 24;  // game label height
const GAP_R1    = 20;  // gap between match blocks in R1
// Full height one R1 match block occupies in the column:
const BLOCK_H   = LABEL_H + MATCH_H + GAP_R1;

function render() {
  const el = document.getElementById('bracket');
  el.innerHTML = '';

  ST.rounds.forEach((round, ri) => {
    // Each match in round ri spans 2^ri R1 blocks vertically
    const span      = Math.pow(2, ri);
    const blockSpan = span * BLOCK_H; // total height for this match

    const col = document.createElement('div');
    col.className = 'round-col';

    // Header
    const hdr = document.createElement('div');
    hdr.className = 'round-header';
    hdr.textContent = ROUND_NAMES[ri] || `Round ${ri+1}`;
    col.appendChild(hdr);

    // Matches
    const matchesEl = document.createElement('div');
    matchesEl.className = 'round-matches';

    round.forEach((match, mi) => {
      const block = document.createElement('div');
      block.className = 'match-block';
      block.style.height = `${blockSpan}px`;

      // Game label
      const lbl = document.createElement('div');
      lbl.className = 'game-label';
      lbl.textContent = `Game ${mi + 1}`;
      block.appendChild(lbl);

      // Card
      const card = document.createElement('div');
      card.className = 'match-card';
      card.setAttribute('data-id', match.id);
      card.appendChild(buildSlot(match, 'top'));
      card.appendChild(buildSlot(match, 'bottom'));
      block.appendChild(card);

      matchesEl.appendChild(block);
    });

    col.appendChild(matchesEl);
    el.appendChild(col);

    // After last round: add connector + champion box inline
    if (ri < ST.rounds.length - 1) {
      const conn = document.createElement('div');
      conn.className = 'connector-col';
      conn.setAttribute('data-ri', ri);
      el.appendChild(conn);
    } else {
      // This is the final round â€” add a short connector then champion box
      const finalConn = document.createElement('div');
      finalConn.className = 'connector-col';
      finalConn.setAttribute('data-ri', ri);
      finalConn.setAttribute('data-final', '1');
      el.appendChild(finalConn);

      const finalWinner = ST.rounds[ST.rounds.length - 1][0]?.winner;
      const champCol = document.createElement('div');
      champCol.className = 'champion-col';

      // Vertically center the champion box relative to the final match
      const finalSpan = Math.pow(2, ri) * BLOCK_H;
      champCol.style.height = `${finalSpan}px`;
      champCol.style.paddingTop = '40px'; // offset for round header

      champCol.innerHTML = `
        <div class="champion-header">ğŸ† Champion</div>
        <div class="champion-box" id="champBox">
          <span class="champ-trophy" id="champTrophy">ğŸ†</span>
          <div class="champ-label">Tournament Champion</div>
          <hr class="champ-divider">
          <div class="champ-team">${finalWinner ? finalWinner.label : 'TBD'}</div>
          <div class="champ-players">${finalWinner ? `${finalWinner.p1}<br>${finalWinner.p2}` : '<span style="color:var(--muted);font-size:0.82rem;">Awaiting finalist</span>'}</div>
        </div>`;
      el.appendChild(champCol);
    }
  });

  setTimeout(drawConnectors, 40);
}

function buildSlot(match, slot) {
  const raw      = slot === 'top' ? match.top : match.bottom;
  // Normalize: treat undefined/null as empty, 'BYE' string as bye, anything else as a team object
  const isBye    = raw === 'BYE';
  const isEmpty  = raw === null || raw === undefined;
  const team     = (!isBye && !isEmpty) ? raw : null;
  const isWinner = team && match.winner && match.winner !== 'BYE' && match.winner.id === team.id;
  const isLoser  = team && match.winner && match.winner !== 'BYE' && match.winner.id !== team.id;

  const div = document.createElement('div');
  div.className = 'team-slot' +
    (isBye    ? ' s-bye'    : '') +
    (isEmpty  ? ' s-empty'  : '') +
    (isWinner ? ' s-winner' : '') +
    (isLoser  ? ' s-loser'  : '');
  div.style.minHeight = `${SLOT_H}px`;

  if (isBye) {
    div.innerHTML = `<div class="slot-tag">Bye</div><div class="slot-names">Auto-Advance âœ“</div>`;
  } else if (isEmpty) {
    div.innerHTML = `<div class="slot-names">TBD</div>`;
  } else {
    div.innerHTML = `
      <div class="slot-tag">${team.label}</div>
      <div class="slot-names">${team.p1} &amp; ${team.p2}</div>
      ${isWinner ? '<span class="win-check">âœ“</span>' : ''}`;
    div.addEventListener('click', () => clickSlot(match.id, slot));
    div.title = `Click to advance ${team.label}`;
  }

  return div;
}

/* â”€â”€â”€ SVG CONNECTORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function drawConnectors() {
  document.querySelectorAll('.connector-svg').forEach(e => e.remove());

  const bracketEl  = document.getElementById('bracket');
  const roundCols  = [...bracketEl.querySelectorAll('.round-col')];
  const connCols   = [...bracketEl.querySelectorAll('.connector-col')];

  connCols.forEach((col, ri) => {
    const fromCol = roundCols[ri];
    const toCol   = roundCols[ri + 1];
    if (!fromCol || !toCol) return;

    const fromCards = [...fromCol.querySelectorAll('.match-card')];
    const toCards   = [...toCol.querySelectorAll('.match-card')];

    const colRect = col.getBoundingClientRect();
    if (colRect.height < 1) return;

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.classList.add('connector-svg');
    svg.style.cssText = `position:absolute;top:0;left:0;width:${colRect.width}px;height:${colRect.height}px;overflow:visible;pointer-events:none;`;
    col.appendChild(svg);

    const COLOR = '#2e3d55';
    const W     = '1.5';

    function ln(x1, y1, x2, y2) {
      const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      l.setAttribute('x1', x1); l.setAttribute('y1', y1);
      l.setAttribute('x2', x2); l.setAttribute('y2', y2);
      l.setAttribute('stroke', COLOR); l.setAttribute('stroke-width', W);
      l.setAttribute('stroke-linecap', 'round');
      svg.appendChild(l);
    }

    toCards.forEach((toCard, i) => {
      const c1 = fromCards[i * 2];
      const c2 = fromCards[i * 2 + 1];
      if (!c1 || !c2 || !toCard) return;

      const top   = colRect.top;
      const y1    = c1.getBoundingClientRect().top    + c1.getBoundingClientRect().height / 2 - top;
      const y2    = c2.getBoundingClientRect().top    + c2.getBoundingClientRect().height / 2 - top;
      const yn    = toCard.getBoundingClientRect().top + toCard.getBoundingClientRect().height / 2 - top;
      const ymid  = (y1 + y2) / 2;
      const xL    = 0;
      const xMid  = colRect.width / 2;
      const xR    = colRect.width;

      ln(xL,   y1,   xMid, y1);    // left card top â†’ midpoint
      ln(xL,   y2,   xMid, y2);    // left card bottom â†’ midpoint
      ln(xMid, y1,   xMid, y2);    // vertical bridge
      ln(xMid, ymid, xR,   ymid);  // center â†’ right
    });
  });
}

window.addEventListener('resize', () => { drawConnectors(); });

/* â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
// Show a loading state while Firebase connects
document.getElementById('bracket').innerHTML =
  '<div style="padding:60px;text-align:center;color:var(--muted);font-family:Barlow Condensed,sans-serif;font-size:1.1rem;letter-spacing:2px;">CONNECTING TO LIVE BRACKET...</div>';

function initApp(firestoreData) {
  if (firestoreData) {
    applyFirestoreState(firestoreData);
  } else {
    // No data in Firestore yet â€” build fresh and save
    buildBracket();
    render();
    if (window._fbSave) {
      window._fbSave({ seed: String(window._currentSeed), picks: [] });
    }
  }

  checkSession();
  document.getElementById('bracket').classList.add('bracket-locked');

  // â”€â”€ Real-time listener: update all viewers when state changes â”€â”€
  if (window._fbListen) {
    window._fbListen(data => {
      if (_ignoreNext) { _ignoreNext = false; return; } // skip our own write echo
      applyFirestoreState(data);
      // Re-apply lock class after render
      if (!isUnlocked) document.getElementById('bracket').classList.add('bracket-locked');
    });
  }
}

// Wait for Firebase to be ready, then load state
if (window._fbReady) {
  window._fbGet().then(initApp);
} else {
  document.addEventListener('fbReady', () => {
    window._fbGet().then(initApp);
  });
}
</script>
</body>
</html>
